
#########################################################################################################
# Import dassflow2d package
# 
# In df2d, you must have a look at 2 submodules
# - df2d.wrapping which is automaticaly generated by f90 wrap (expet the .__init__ file), and enable the fortran subroutines calls
# - df2d.DassFlow model, that creat a class. This class enable the call of multiple python functions and the storage in python format of main data
#                           these python functions mainly use calls to df2d.wrapping submodule 
#########################################################################################################
import dassflow2d as df2d
import os 
import re    


# define main libs
# function that perform "grep" within files to return
# path to source files
# this funciton can be applied and df2d function, but not the getters and setters
def help_dev(df2d_function = df2d.wrapping.read_input, 
                 wrappers_true_directory= '/home/livillenave/Documents/distant/dassflow2d-wrap/code/wrappers_true/',
                 wrappers_directory= '/home/livillenave/Documents/distant/dassflow2d-wrap/code/wrappers/', 
                 cpp_directory=      "/home/livillenave/Documents/distant/dassflow2d-wrap/code/cpp",
                 src_directory=      "/home/livillenave/Documents/distant/dassflow2d-wrap/code/src"):
    
    
    print(f"-- package directory : {df2d.__path__[0]}")
    module = df2d_function.__module__
    name = df2d_function.__name__
    
    print("================================================")                            
    print("Historic of ",df2d_function)
    print("================================================") 
    
      
    print("-----------------------------------------------")                            
    print("python function information")
    print("-----------------------------------------------") 
    print("-- class  : ", df2d_function.__class__)  
    print("-- module : ", module)       
    print("-- name   : ",name)    
    
    
    print("-----------------------------------------------")                            
    print("Source files infomation -- WRAPPERS_TRUE PART")
    print("-----------------------------------------------") 
    
    print(f"-- compilation directory :  {wrappers_true_directory}")
    print(f"-- f90wrap generated directory : {wrappers_directory}")
    
    
    ##### search .so file in wrappers_true
    # get name of the wrapped function corresponding to python df2d guntion
    dir_path = f'{wrappers_true_directory}/dassflow2d/wrapping'
    
    # search in fortran files        
    xs =  os.listdir(dir_path)
    files = [x for x in xs if  ".so" in x][0]
    
    print(f"-- file name : {files}")
    print(f" \n \n This file (*/so) comes from \n {wrappers_directory} directory")
    
    
    
    print("-----------------------------------------------")                            
    print("Source files infomation -- WRAPPED PART")
    print("-----------------------------------------------") 
    
    
    dir_path = wrappers_directory
    
    # get name of the wrapped function corresponding to python df2d guntion
    try: # for classical method
        search = df2d_function.__code__.co_names[1]    
        all_files = [f"{dir_path}/{x}" for x in os.listdir(dir_path)  if ".f90" in x]
    except: # for getter setter defined into wrapping subdirectory
    
        search =  df2d_function.__code__.co_name
        all_files = [f"{dir_path}/wrapping/{x}" for x in os.listdir(f"{dir_path}/wrapping") if ".f90" in x]
    
    for file in all_files:
        
        # check if it is a file
        if os.path.isfile(file):
            with open(file, 'r') as tmp:
                # read all content of a file and search string
                if re.search(search, tmp.read(), re.IGNORECASE):
                    with open(tmp.name, 'r') as fp:
                        for l_no, line in enumerate(fp):
                            # search string
                            if search in line:
                                break
    
    
    print(f"-- directory       :  {dir_path}")
    print(f"-- subroutine file :  {tmp.name}")
    print(f"-- subroutine name : {line}")
    print(f"-- definition line : {l_no+1}")
    
    print("-----------------------------------------------")                            
    print("Source files infomation -- CPP PART")
    print("-----------------------------------------------") 
    
    xx = df2d_function.__doc__
    start = xx.find("Defined at")
    stop = xx.find("\n", start)
    file= xx[start:stop]
    
    file_name =  file[file.find("at")+2:file.find(".f90")+4]
    lines = file[file.find("lines")+6:]
    print(f"-- cpp directory : {cpp_directory}")
    print(f"-- file name : {file_name}")
    print(f"-- definition line : {lines}")
    
    
    
    
    
    print("-----------------------------------------------")                            
    print("Source files infomation -- SRC PART")
    print("-----------------------------------------------") 
    dir_path = src_directory
    
    
    
    # get name of the wrapped function corresponding to python df2d guntion
    search = f"SUBROUTINE {df2d_function.__code__.co_names[1][8:]}"
    src_dirs = [f"{src_directory}/{i}" for i in os.listdir(src_directory)]
    # exclude wrappers dir
    all_files = []
    for my_dir in src_dirs:
        tmp = [f"{my_dir}/{i}" for i in os.listdir(my_dir)]
        all_files.append(tmp)
    
    i =False
    for unlist_files in all_files:
        for my_file in unlist_files:
         # search in file
#             print(my_file)
#             print( "/home/livillenave/Documents/distant/dassflow2d-wrap/code/src/sw_mono/call_run_model.f90")
#             print(file_name.strip() in my_file)
             if file_name.strip() in my_file: 
                i=True               
                break
        if i :
            break
       
    file = my_file
    cur_path = os.path.join(dir_path, file)
    # check if it is a file
    if os.path.isfile(cur_path):
        with open(cur_path, 'r') as file:
            # read all content of a file and search string
            if re.search(search, file.read(), re.IGNORECASE):
                with open(file.name, 'r') as fp:
                    for l_no, line in enumerate(fp):
                        # search string
                        if search in line:
                            break
                        
    f = open(cur_path, "r")
    i=0
    for x in f:
        i=i+1
        a = re.search(search, x, re.IGNORECASE)
        if   re.search(search, x, re.IGNORECASE) is not None:
            break
      
    line = a.string
    l_no = i    
    print(f"-- subroutine file :  {file.name}")
    print(f"-- subroutine name  : {line}")
    print(f"-- definition line  : {l_no}")



#########################################################################################################
# Your simulation will always be involved in a bin_directory, 
# this is the base repertory, this is where your:
# - input files (mesh.geo, bc.txt, hydrograph.txt, ratcurve.txt, etc...) are stored, 
# - results files will be writen
# - eventual plots will be written
# in all script you will get, you have to adapt this path with your own bin directory  
########################################################################################################

# main directory
dassflow_dir="/home/livillenave/Documents/distant/dassflow2d-wrap/"
# code directory, where compilation happens
code_dir =  f"{dassflow_dir}/code/"
# bin directory, where simulation happens
bin_dir = f"{code_dir}/bin_A/"

# you will you dassflow2d package, in this tutorial, only the wrapping module (only part of the module) is presented.
# the wrapping module enable fortran kernel comunication
help(df2d)
help(df2d.wrapping)


#########################################################################################################
# First, as always, you must work in your bin directory
#########################################################################################################
os.chdir(bin_dir)
#########################################################################################################
# This is your first call of a wrapped function, 
#########################################################################################################
df2d.wrapping.read_input(f"{bin_dir}input.txt")

help(df2d.wrapping.read_input)                           # help of this method
help_dev(df2d.wrapping.read_input) 
#########################################################################################################
# initialise MPI treatment in fortran kernel
# necessary both in MPI and non MPI case
#########################################################################################################
df2d.wrapping.m_mpi.init_mpi()
help(df2d.wrapping.m_mpi.init_mpi())
help_dev(df2d.wrapping.m_mpi.init_mpi)

# get the rank and number of processors
rank = df2d.wrapping.m_mpi.get_proc()
nproc = df2d.wrapping.m_mpi.get_np()
help(df2d.wrapping.m_mpi.get_proc)
help(df2d.wrapping.m_mpi.get_np)

#########################################################################################################
# Fortran subroutines can be found using the command from src directory
# grep -rin 'subroutine_name'      
# this will show you were the  subroutine is involvedInitialise the model
#########################################################################################################


# call Model_initialise()
model = df2d.wrapping.call_model.Model()
help(df2d.wrapping.call_model.Model)    
# >>> Note:
# model is of defined class "model"class which is automaticaly generated by f90wrap:
print(model.__class__)    

# initialise mesh object
msh = df2d.wrapping.m_mesh.msh()
# directly accessible data are available under the flag
# |  Data descriptors 
help(df2d.wrapping.m_mesh.msh)
# Data descriptors inherited from derived types
# can be view seeing the associated dictionary of the object
df2d.wrapping.m_mesh.msh.__dict__

# at the moment, the object mesh is not associated to the object model
print(model.__dict__) # the oject remain inchanged
model.mesh = msh      # link to model object the msh object
del msh # delete now useless msh object
print(model.__dict__) # this object has been linked to model class

# same can be done for the objects dof and dof0 (the unkowns of the problem)

model.dof  = df2d.wrapping.m_model.unk(model.mesh)
model.dof0 = model.dof 
print(model.__dict__) # 


# then initialise solver
df2d.wrapping.call_model.init_solver(model)
help_dev(df2d_function=df2d.wrapping.call_model.init_solver)
help(df2d.wrapping.call_model.init_solver)



# initialise remaining variables
df2d.wrapping.call_model.init_fortran(model)
help(df2d.wrapping.call_model.init_fortran)
help_dev(df2d.wrapping.call_model.init_fortran)

# run model
df2d.wrapping.call_model.run(model, arg = "direct")
help(df2d.wrapping.call_model.run)
help_dev(df2d.wrapping.call_model.run)

# deallocate model6
df2d.wrapping.call_model.clean_model(model)
help(df2d.wrapping.call_model.clean_model)
help_dev(df2d.wrapping.call_model.clean_model)

# ##############################
# once you deallocated model, you can perform again
# a new simulation in the same script
# WARNING: deallocation is troublesome and tracking all deallocation is hard
# debug is still necessary on this issue.*#
#
# ---
# below, a condensed version of the above script is proposed
# ################################
os.chdir(code_dir)
os.system("make cleanres")               # removes all in bin_dir/res directory
os.system("make cleanmsh")               # removes all in bin_dir/msh directory
os.system(f"rm {bin_dir}/restart.bin")   # removes all in bin_dir/msh directory
os.chdir(bin_dir)
df2d.wrapping.read_input(f"{bin_dir}input.txt")  

df2d.wrapping.m_mpi.init_mpi()
rank = df2d.wrapping.m_mpi.get_proc()
nproc = df2d.wrapping.m_mpi.get_np()

model = df2d.wrapping.call_model.Model()
model.mesh = df2d.wrapping.m_mesh.msh()
model.dof  = df2d.wrapping.m_model.unk(model.mesh)
model.dof0 = model.dof 
df2d.wrapping.call_model.init_solver(model)
df2d.wrapping.call_model.init_fortran(
model)
df2d.wrapping.call_model.run(model, arg = "direct")
df2d.wrapping.call_model.clean_model(model)