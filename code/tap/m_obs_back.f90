!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (master) -  9 Oct 2020 17:47
!
MODULE M_OBS_BACK

  USE M_TAP_VARS

CONTAINS
!  Differentiation of calc_cost_function in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: *(*innovation.diff) cost
!   with respect to varying inputs: *(*(bc.hyd).q) *(*innovation.diff)
!                cost
!   Plus diff mem management of: bc.hyd:in *(bc.hyd).q:in innovation:in
!                *innovation.diff:in
  SUBROUTINE CALC_COST_FUNCTION_BACK(cost, cost_back, mesh)
    USE M_NUMERIC_BACK
    IMPLICIT NONE
    TYPE(MSH), INTENT(IN) :: mesh
    REAL(rp), INTENT(INOUT) :: cost
    REAL(rp), INTENT(INOUT) :: cost_back
    REAL(rp) :: cost_part(3), filtered(4)
    REAL(rp) :: cost_part_back(3), filtered_back(4)
    INTEGER(ip) :: idiff
    TYPE(VEC2D), DIMENSION(mesh%nc+mesh%ncb) :: grad_var
    INTRINSIC SIZE
    INTRINSIC SUM
    INTRINSIC SQRT
    REAL(rp) :: temp_back
    INTEGER*4 :: ad_to
    INTEGER*4 :: ad_to0
    INTEGER*4 :: ad_to1
    INTEGER :: ii1
    INTEGER :: branch
    IF (use_obs .EQ. 1) THEN
      cost_part(:) = 0._rp
      DO iobs=1,SIZE(station)
        DO idiff=1,SIZE(innovation(iobs)%diff)
          cost_part(1) = cost_part(1) + station(iobs)%weight*innovation(&
&           iobs)%diff(idiff)**2
        END DO
        CALL PUSHINTEGER4(idiff - 1)
      END DO
      CALL PUSHINTEGER4(iobs - 1)
      DO i=1,mesh%nc
        cost_part(2) = cost_part(2) + (grad_var(i)%x**2+grad_var(i)%y**2&
&         )
      END DO
      cost_part(2) = cost_part(2)*regul_bathy
      DO k=1,bc%nb_in
        CALL PUSHREAL8(filtered(1))
        filtered(1) = bc%hyd(k)%q(1)
        DO i=2,SIZE(bc%hyd(k)%q(:))-3
          CALL PUSHREAL8(filtered(2))
          filtered(2) = filtered(1) + 0.2_rp*(bc%hyd(k)%q(i)-filtered(1)&
&           )
          CALL PUSHREAL8(filtered(3))
          filtered(3) = filtered(2) + 0.2_rp*(bc%hyd(k)%q(i+1)-filtered(&
&           2))
          CALL PUSHREAL8(filtered(4))
          filtered(4) = filtered(3) + 0.2_rp*(bc%hyd(k)%q(i+2)-filtered(&
&           3))
          cost_part(3) = cost_part(3) + (bc%hyd(k)%q(i)-filtered(4))**2
          CALL PUSHREAL8(filtered(1))
          filtered(1) = filtered(4)
        END DO
        CALL PUSHINTEGER4(i - 1)
      END DO
      cost_part(3) = cost_part(3)*regul_hydrograph
      cost = SUM(cost_part)
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (cost**2 .EQ. 0.0) THEN
      cost_back = 0.0_8
    ELSE
      cost_back = 2*cost*cost_back/(2.0*SQRT(cost**2))
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      cost_part_back = 0.0_8
      cost_part_back = cost_back
      cost_part_back(3) = regul_hydrograph*cost_part_back(3)
      DO ii1=1,SIZE(bc_back%hyd(ii1)%q, 1)
        bc_back%hyd(ii1)%q = 0.0_8
      END DO
      filtered_back = 0.0_8
      DO k=bc%nb_in,1,-1
        CALL POPINTEGER4(ad_to1)
        DO i=ad_to1,2,-1
          temp_back = 2*(bc%hyd(k)%q(i)-filtered(4))*cost_part_back(3)
          CALL POPREAL8(filtered(1))
          filtered_back(4) = filtered_back(4) + filtered_back(1) - &
&           temp_back
          bc_back%hyd(k)%q(i) = bc_back%hyd(k)%q(i) + temp_back
          CALL POPREAL8(filtered(4))
          filtered_back(3) = filtered_back(3) + 0.8*filtered_back(4)
          bc_back%hyd(k)%q(i+2) = bc_back%hyd(k)%q(i+2) + 0.2_rp*&
&           filtered_back(4)
          filtered_back(4) = 0.0_8
          CALL POPREAL8(filtered(3))
          filtered_back(2) = filtered_back(2) + 0.8*filtered_back(3)
          filtered_back(1) = 0.8*filtered_back(2)
          bc_back%hyd(k)%q(i+1) = bc_back%hyd(k)%q(i+1) + 0.2_rp*&
&           filtered_back(3)
          filtered_back(3) = 0.0_8
          CALL POPREAL8(filtered(2))
          bc_back%hyd(k)%q(i) = bc_back%hyd(k)%q(i) + 0.2_rp*&
&           filtered_back(2)
          filtered_back(2) = 0.0_8
        END DO
        CALL POPREAL8(filtered(1))
        bc_back%hyd(k)%q(1) = bc_back%hyd(k)%q(1) + filtered_back(1)
        filtered_back(1) = 0.0_8
      END DO
      cost_part_back(2) = regul_bathy*cost_part_back(2)
      CALL POPINTEGER4(ad_to0)
      DO iobs=ad_to0,1,-1
        CALL POPINTEGER4(ad_to)
        DO idiff=ad_to,1,-1
          innovation_back(iobs)%diff(idiff) = innovation_back(iobs)%diff&
&           (idiff) + 2*innovation(iobs)%diff(idiff)*station(iobs)%&
&           weight*cost_part_back(1)
        END DO
      END DO
      cost_back = 0.0_8
    ELSE
      DO ii1=1,SIZE(bc_back%hyd(ii1)%q, 1)
        bc_back%hyd(ii1)%q = 0.0_8
      END DO
    END IF
  END SUBROUTINE CALC_COST_FUNCTION_BACK


!  Differentiation of update_cost_function in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: *(dof.h) cost
!   with respect to varying inputs: *(dof.h) cost
!   Plus diff mem management of: dof.h:in
  SUBROUTINE UPDATE_COST_FUNCTION_BACK(dof, dof_back, cost, cost_back)
    IMPLICIT NONE
    TYPE(UNK), INTENT(IN) :: dof
    TYPE(UNK) :: dof_back
    REAL(rp), INTENT(INOUT) :: cost
    REAL(rp), INTENT(INOUT) :: cost_back
    INTEGER(ip) :: cell, pt
    REAL(rp) :: h_mean
    REAL(rp) :: h_mean_back
    INTRINSIC ALLOCATED
    INTRINSIC SIZE
    INTRINSIC REAL
    LOGICAL :: result1
    INTEGER*4 :: ad_to
    INTEGER :: branch
    INTEGER*4 :: ad_to0
    IF (ALLOCATED(station)) THEN
      DO iobs=1,SIZE(station)
        result1 = TEST_DT_JUST_AFTER(station(iobs)%dt)
        IF (.NOT.result1) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHREAL8(h_mean)
          h_mean = 0._rp
          DO pt=1,SIZE(station(iobs)%pt)
            cell = station(iobs)%pt(pt)%cell
            IF (cell .LT. 0) THEN
              CALL PUSHCONTROL1B(0)
            ELSE
              h_mean = h_mean + dof%h(cell)
              CALL PUSHCONTROL1B(1)
            END IF
          END DO
          CALL PUSHINTEGER4(pt - 1)
          h_mean = h_mean/REAL(SIZE(station(iobs)%pt), 8)
          CALL PUSHCONTROL1B(1)
        END IF
      END DO
      ad_to0 = iobs - 1
      DO iobs=ad_to0,1,-1
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) THEN
          h_mean_back = 2*h_mean*station(iobs)%weight*cost_back
          h_mean_back = h_mean_back/REAL(SIZE(station(iobs)%pt), 8)
          CALL POPINTEGER4(ad_to)
          DO pt=ad_to,1,-1
            CALL POPCONTROL1B(branch)
            IF (branch .NE. 0) THEN
              cell = station(iobs)%pt(pt)%cell
              dof_back%h(cell) = dof_back%h(cell) + h_mean_back
            END IF
          END DO
          CALL POPREAL8(h_mean)
        END IF
      END DO
    END IF
  END SUBROUTINE UPDATE_COST_FUNCTION_BACK


END MODULE M_OBS_BACK

