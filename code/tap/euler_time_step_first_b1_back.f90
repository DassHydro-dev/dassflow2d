!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (master) -  9 Oct 2020 17:47
!
!  Differentiation of euler_time_step_first_b1 in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: *(infil.ga).psif *(infil.ga).ks
!                *(infil.ga).deltatheta *(infil.scs).lambda *(infil.scs).cn
!                *manning *(bc.inflow) *(bc.outflow) *(bc.rain).qin
!                *(bc.rain).cumul *(bc.sum_mass_flux) *bathy_cell
!                *manning_beta *(dof.h) *(dof.u) *(dof.v) *(dof.infil)
!   with respect to varying inputs: *(infil.ga).psif *(infil.ga).ks
!                *(infil.ga).deltatheta *(infil.scs).lambda *(infil.scs).cn
!                *manning *(bc.inflow) *(bc.outflow) *(bc.rain).qin
!                *(bc.rain).cumul *(bc.sum_mass_flux) *bathy_cell
!                *manning_beta *(dof.h) *(dof.u) *(dof.v) *(dof.infil)
!   Plus diff mem management of: infil.ga:in infil.scs:in manning:in
!                bc.inflow:in bc.outflow:in bc.hpresc:in *(bc.hpresc).t:in
!                *(bc.hpresc).h:in bc.zspresc:in *(bc.zspresc).t:in
!                *(bc.zspresc).z:in bc.rain:in bc.sum_mass_flux:in
!                bathy_cell:in manning_beta:in dof.h:in dof.u:in
!                dof.v:in dof.infil:in
SUBROUTINE EULER_TIME_STEP_FIRST_B1_BACK(dof, dof_back, mesh)
  USE M_COMMON ! Replaced by Perl Script
  USE M_MESH ! Replaced by Perl Script
  USE M_MODEL ! Replaced by Perl Script

  USE M_TAP_VARS ! Added by Perl Script -> Need to be filled !!!

  IMPLICIT NONE
  TYPE(MSH), INTENT(INOUT) :: mesh
  TYPE(UNK), INTENT(INOUT) :: dof
  TYPE(UNK), INTENT(INOUT) :: dof_back
! Left and Right cells indexes to edge
  INTEGER(ip) :: il, ir
! Left State in edge cell normal coordinates
  REAL(rp) :: hl(2), ul(2), vl(2), zl
  REAL(rp) :: hl_back(2), ul_back(2), vl_back(2), zl_back
! Right State in edge cell normal coordinates
  REAL(rp) :: hr(2), ur(2), vr(2), zr
  REAL(rp) :: hr_back(2), ur_back(2), vr_back(2), zr_back
! Finite Volume normal edge flux
  REAL(rp), DIMENSION(sw_nb) :: nflux
  REAL(rp), DIMENSION(sw_nb) :: nflux_back
! Finite Volume edge flux in (x,y) coordinates
  REAL(rp), DIMENSION(sw_nb) :: lflux
  REAL(rp), DIMENSION(sw_nb) :: lflux_back
! Finite Volume total flux for each cell
  REAL(rp), DIMENSION(sw_nb, mesh%nc) :: tflux
  REAL(rp), DIMENSION(sw_nb, mesh%nc) :: tflux_back
! Temporal primitive variables
  REAL(rp) :: h, u, v
  REAL(rp) :: h_back, u_back, v_back
! potential maximal retention
  REAL(rp) :: s
  REAL(rp) :: s_back
! Temporal Fn+1
  REAL(rp) :: fn1
  REAL(rp) :: fn1_back
  REAL(rp) :: afn1, bfn1
  REAL(rp) :: afn1_back, bfn1_back
! local variable of infil calculated depth 
  REAL(rp) :: h_infil
  REAL(rp) :: h_infil_back
! Velocity norm
  REAL(rp) :: vel
  REAL(rp) :: vel_back
! Manning
  REAL(rp) :: sfl
  REAL(rp) :: sfl_back
! mass rain >TGADJ
  REAL(rp) :: madd
  INTRINSIC MAX
  INTRINSIC ABS
  INTRINSIC SQRT
  REAL(rp) :: y1
  REAL(rp) :: y1_back
  REAL(rp) :: y2
  REAL(rp) :: y2_back
  REAL(rp) :: abs0
  REAL(rp) :: abs0_back
  REAL(rp) :: abs1
  REAL(rp) :: abs2
  REAL(rp) :: abs2_back
  REAL(rp) :: max1
  REAL(rp) :: max1_back
  REAL(rp) :: max2
  REAL(rp) :: max2_back
  REAL(rp) :: abs3
  REAL(rp) :: abs3_back
  REAL(rp) :: abs4
  REAL(rp) :: abs4_back
  INTEGER :: branch
  REAL(rp) :: temp
  REAL(rp) :: temp_back
  REAL(rp) :: temp0
  REAL(rp) :: temp_back0
  REAL(rp) :: temp1
  REAL(rp) :: temp_back1
  REAL(rp) :: temp2
  REAL(rp) :: temp_back2
  REAL(rp) :: temp_back3
  REAL(rp) :: temp_back4
  tflux(:, :) = 0._rp
  DO 100 ie=1,mesh%ne
    CALL PUSHINTEGER4(il)
    il = mesh%edge(ie)%cell(1)
!Left cell id for a normal cell
    CALL PUSHINTEGER4(ir)
    ir = mesh%edge(ie)%cell(2)
    IF (mesh%edge(ie)%boundary) THEN
!Check if bounfary first so typlim exists
      IF (mesh%edgeb(mesh%edge(ie)%lim)%typlim .EQ. 'internal_1D') THEN
        CALL PUSHCONTROL3B(0)
        GOTO 100
      ELSE IF (mesh%edgeb(mesh%edge(ie)%lim)%typlim .EQ. 'internal_2D') &
&     THEN
        CALL PUSHCONTROL1B(0)
!then change connectivity to connected 1D-like cell
!Get id of the single 1D-like cell with interface in the connected bc number => this should be done once!
        ir = mesh%edge(ie)%cell1d2d
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    CALL PUSHREAL8(hl(1))
    hl(1) = dof%h(il)
    CALL PUSHREAL8(hr(1))
    hr(1) = dof%h(ir)
    IF (hl(1) .GT. heps .OR. hr(1) .GT. heps) THEN
! + global_bathy_shift(1)
      zl = bathy_cell(il)
! + global_bathy_shift(1)
      zr = bathy_cell(ir)
      CALL PUSHREAL8(ul(1))
      ul(1) = dof%u(il)
      CALL PUSHREAL8(vl(1))
      vl(1) = dof%v(il)
      CALL PUSHREAL8(ul(2))
      ul(2) = mesh%edge(ie)%normal%x*ul(1) + mesh%edge(ie)%normal%y*vl(1&
&       )
      CALL PUSHREAL8(vl(2))
      vl(2) = mesh%edge(ie)%normal%x*vl(1) - mesh%edge(ie)%normal%y*ul(1&
&       )
      IF (mesh%edge(ie)%boundary) THEN
        IF (.NOT.mesh%edgeb(mesh%edge(ie)%lim)%typlim .EQ. 'internal_2D'&
&       ) THEN
!do not call boundary calculations for internal BCs
          CALL PUSHREAL8(vr(2))
          CALL PUSHREAL8(ur(2))
          CALL PUSHREAL8(hr(1))
          CALL CALC_BOUNDARY_STATE(mesh, hl(1), zl, ul(2), vl(2)& ! Replaced by Perl Script
&                                   , hr(1), zr, ur(2), vr(2))
          CALL PUSHCONTROL2B(0)
        ELSE
          CALL PUSHREAL8(ur(1))
          ur(1) = dof%u(ir)
          CALL PUSHREAL8(vr(1))
          vr(1) = dof%v(ir)
          CALL PUSHREAL8(ur(2))
          ur(2) = mesh%edge(ie)%normal%x*ur(1) + mesh%edge(ie)%normal%y*&
&           vr(1)
          CALL PUSHREAL8(vr(2))
          vr(2) = mesh%edge(ie)%normal%x*vr(1) - mesh%edge(ie)%normal%y*&
&           ur(1)
          CALL PUSHCONTROL2B(1)
        END IF
      ELSE
        CALL PUSHREAL8(ur(1))
        ur(1) = dof%u(ir)
        CALL PUSHREAL8(vr(1))
        vr(1) = dof%v(ir)
        CALL PUSHREAL8(ur(2))
        ur(2) = mesh%edge(ie)%normal%x*ur(1) + mesh%edge(ie)%normal%y*vr&
&         (1)
        CALL PUSHREAL8(vr(2))
        vr(2) = mesh%edge(ie)%normal%x*vr(1) - mesh%edge(ie)%normal%y*ur&
&         (1)
        CALL PUSHCONTROL2B(2)
      END IF
      IF (zl .LT. zr) THEN
        max1 = zr
        CALL PUSHCONTROL1B(0)
      ELSE
        max1 = zl
        CALL PUSHCONTROL1B(1)
      END IF
      y1 = hl(1) + zl - max1
      IF (0._rp .LT. y1) THEN
        CALL PUSHREAL8(hl(2))
        hl(2) = y1
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHREAL8(hl(2))
        hl(2) = 0._rp
        CALL PUSHCONTROL1B(1)
      END IF
      IF (zl .LT. zr) THEN
        max2 = zr
        CALL PUSHCONTROL1B(0)
      ELSE
        max2 = zl
        CALL PUSHCONTROL1B(1)
      END IF
      y2 = hr(1) + zr - max2
      IF (0._rp .LT. y2) THEN
        CALL PUSHREAL8(hr(2))
        hr(2) = y2
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHREAL8(hr(2))
        hr(2) = 0._rp
        CALL PUSHCONTROL1B(1)
      END IF
      CALL PUSHREAL8ARRAY(nflux, 3)
      CALL SW_HLLC(hl(2), ul(2), vl(2), hr(2), ur(2), vr(2), & ! Replaced by Perl Script
&                   nflux)
      IF (mesh%edge(ie)%boundary) THEN
        IF (ALLOCATED(bathy_cell)) THEN
          CALL PUSHREAL8ARRAY(bathy_cell, SIZE(bathy_cell, 1))
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
        CALL PUSHREAL8ARRAY(bc%sum_mass_flux, SIZE(bc%sum_mass_flux, 1))
        CALL BOUNDARY_POST(nflux(1), ir, mesh) ! Replaced by Perl Script
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      lflux(1) = nflux(1)
      lflux(2) = mesh%edge(ie)%normal%x*nflux(2) - mesh%edge(ie)%normal%&
&       y*nflux(3)
      lflux(3) = mesh%edge(ie)%normal%y*nflux(2) + mesh%edge(ie)%normal%&
&       x*nflux(3)
      lflux(1:3) = lflux(1:3)*mesh%edge(ie)%length
      tflux(1, il) = tflux(1, il) + lflux(1)
      tflux(2, il) = tflux(2, il) + lflux(2)
      tflux(3, il) = tflux(3, il) + lflux(3)
      tflux(2, il) = tflux(2, il) + mesh%edge(ie)%normal%x*mesh%edge(ie)&
&       %length*0.5_rp*g*(hl(1)**2-hl(2)**2)
      tflux(3, il) = tflux(3, il) + mesh%edge(ie)%normal%y*mesh%edge(ie)&
&       %length*0.5_rp*g*(hl(1)**2-hl(2)**2)
      IF (.NOT.mesh%edge(ie)%boundary .AND. (.NOT.mesh%edge(ie)%&
&         subdomain)) THEN
        tflux(1, ir) = tflux(1, ir) - lflux(1)
        tflux(2, ir) = tflux(2, ir) - lflux(2)
        tflux(3, ir) = tflux(3, ir) - lflux(3)
        tflux(2, ir) = tflux(2, ir) - mesh%edge(ie)%normal%x*mesh%edge(&
&         ie)%length*0.5_rp*g*(hr(1)**2-hr(2)**2)
        tflux(3, ir) = tflux(3, ir) - mesh%edge(ie)%normal%y*mesh%edge(&
&         ie)%length*0.5_rp*g*(hr(1)**2-hr(2)**2)
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      IF (mesh%edge(ie)%boundary) THEN
        IF (mesh%edgeb(mesh%edge(ie)%lim)%typlim .EQ. 'internal_2D') &
&       THEN
          tflux(1, ir) = tflux(1, ir) - lflux(1)
          tflux(2, ir) = tflux(2, ir) - lflux(2)
          tflux(3, ir) = tflux(3, ir) - lflux(3)
          tflux(2, ir) = tflux(2, ir) - mesh%edge(ie)%normal%x*mesh%edge&
&           (ie)%length*0.5_rp*g*(hr(1)**2-hr(2)**2)
          tflux(3, ir) = tflux(3, ir) - mesh%edge(ie)%normal%y*mesh%edge&
&           (ie)%length*0.5_rp*g*(hr(1)**2-hr(2)**2)
          CALL PUSHCONTROL3B(4)
        ELSE
          CALL PUSHCONTROL3B(3)
        END IF
      ELSE
        CALL PUSHCONTROL3B(2)
      END IF
    ELSE
      CALL PUSHCONTROL3B(1)
    END IF
 100 CONTINUE
  DO k=1,bc%nb_rn
    bc%rain(k)%cumul = bc%rain(k)%cumul + dt*bc%rain(k)%qin
  END DO
  DO i=1,mesh%nc
    CALL PUSHREAL8(h)
    h = dof%h(i)
    CALL PUSHREAL8(u)
    u = dof%u(i)
    CALL PUSHREAL8(v)
    v = dof%v(i)
    IF (0._rp .LT. h - dt*tflux(1, i)*mesh%cell(i)%invsurf) THEN
      CALL PUSHREAL8(dof%h(i))
      dof%h(i) = h - dt*tflux(1, i)*mesh%cell(i)%invsurf
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHREAL8(dof%h(i))
      dof%h(i) = 0._rp
      CALL PUSHCONTROL1B(1)
    END IF
    IF (bc_rain .EQ. 1) THEN
!Get rain group for current cell
      k = mesh%cell(i)%rain
      IF (k .GT. 0) THEN
        IF (bc_infil .EQ. 2 .AND. infil%land(i) .NE. 0) THEN
          IF (infil%scs(infil%land(i))%cn .GE. 0.) THEN
            CALL PUSHREAL8(abs0)
            abs0 = infil%scs(infil%land(i))%cn
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHREAL8(abs0)
            abs0 = -infil%scs(infil%land(i))%cn
            CALL PUSHCONTROL1B(1)
          END IF
! infil%land(i) is infiltration group for current cell
          s = 25.4_rp*(1000._rp/abs0-10._rp)/1000._rp
          IF (infil%scs(infil%land(i))%lambda .GE. 0.) THEN
            abs1 = infil%scs(infil%land(i))%lambda
          ELSE
            abs1 = -infil%scs(infil%land(i))%lambda
          END IF
          IF (bc%rain(k)%cumul .GT. abs1*s) THEN
            IF (infil%scs(infil%land(i))%lambda .GE. 0.) THEN
              CALL PUSHREAL8(abs2)
              abs2 = infil%scs(infil%land(i))%lambda
              CALL PUSHCONTROL1B(1)
            ELSE
              CALL PUSHREAL8(abs2)
              abs2 = -infil%scs(infil%land(i))%lambda
              CALL PUSHCONTROL1B(0)
            END IF
            IF (infil%scs(infil%land(i))%lambda .GE. 0.) THEN
              CALL PUSHREAL8(abs3)
              abs3 = infil%scs(infil%land(i))%lambda
              CALL PUSHCONTROL1B(1)
            ELSE
              CALL PUSHREAL8(abs3)
              abs3 = -infil%scs(infil%land(i))%lambda
              CALL PUSHCONTROL1B(0)
            END IF
            IF (infil%scs(infil%land(i))%lambda .GE. 0.) THEN
              CALL PUSHREAL8(abs4)
              abs4 = infil%scs(infil%land(i))%lambda
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHREAL8(abs4)
              abs4 = -infil%scs(infil%land(i))%lambda
              CALL PUSHCONTROL1B(1)
            END IF
            fn1 = abs2*s + s*(bc%rain(k)%cumul-abs3*s)/(bc%rain(k)%cumul&
&             +(1-abs4)*s)
            CALL PUSHCONTROL1B(0)
          ELSE
            fn1 = dof%infil(i) + dt*bc%rain(k)%qin
            CALL PUSHCONTROL1B(1)
          END IF
!SCS-modified rain
          CALL PUSHREAL8(dof%h(i))
          dof%h(i) = dof%h(i) + dt*bc%rain(k)%qin - fn1 + dof%infil(i)
          CALL PUSHREAL8(dof%infil(i))
          dof%infil(i) = fn1
          CALL PUSHCONTROL2B(0)
        ELSE
!Unmodified rain
          CALL PUSHREAL8(dof%h(i))
          dof%h(i) = dof%h(i) + dt*bc%rain(k)%qin
          CALL PUSHCONTROL2B(1)
        END IF
      ELSE
        CALL PUSHCONTROL2B(2)
      END IF
    ELSE
      CALL PUSHCONTROL2B(3)
    END IF
    IF (bc_infil .EQ. 1) THEN
      IF (infil%land(i) .NE. 0) THEN
!CHECK FORMULATION !CHECK FORMULATION
        CALL PUSHREAL8(afn1)
        afn1 = dof%infil(i) + dt*infil%ga(infil%land(i))%ks*(1._rp-infil&
&         %ga(infil%land(i))%deltatheta)
! infil%land(i) is infiltration group for current cell
        CALL PUSHREAL8(bfn1)
        bfn1 = infil%ga(infil%land(i))%ks*dt*infil%ga(infil%land(i))%&
&         deltatheta*(dof%infil(i)+dof%h(i)+infil%ga(infil%land(i))%psif&
&         )
!CHECK FORMULATION
        fn1 = (afn1+SQRT(afn1**2._rp+4._rp*bfn1))/2._rp
        h_infil = dof%h(i) + dof%infil(i) - fn1
!-------original code-------
! dof%h(i) = 0._rp
        IF (h_infil .LT. 0._rp) THEN
          fn1 = dof%h(i) + dof%infil(i)
          h_infil = 0.000001_rp
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
!replace the local variable h_infil
        CALL PUSHREAL8(dof%h(i))
        dof%h(i) = h_infil
        CALL PUSHREAL8(dof%infil(i))
        dof%infil(i) = fn1
        CALL PUSHCONTROL2B(0)
      ELSE
        CALL PUSHCONTROL2B(1)
      END IF
    ELSE
      CALL PUSHCONTROL2B(2)
    END IF
    IF (dof%h(i) .LE. heps) THEN
      CALL PUSHREAL8(dof%u(i))
      dof%u(i) = 0._rp
      CALL PUSHREAL8(dof%v(i))
      dof%v(i) = 0._rp
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHREAL8(dof%u(i))
      dof%u(i) = (h*u-dt*(tflux(2, i)*mesh%cell(i)%invsurf))/dof%h(i)
      CALL PUSHREAL8(dof%v(i))
      dof%v(i) = (h*v-dt*(tflux(3, i)*mesh%cell(i)%invsurf))/dof%h(i)
      IF (friction .EQ. 1) THEN
        CALL PUSHREAL8(vel)
        vel = SQRT(dof%u(i)**2 + dof%v(i)**2)
        CALL PUSHREAL8(sfl)
        sfl = dof%h(i)**d2p3 + SQRT(dof%h(i)**d4p3 + 4._rp*dt*g*(manning&
&         (land(i))*dof%h(i)**manning_beta(land(i)))**2*vel)
        CALL PUSHREAL8(sfl)
        sfl = 2._rp*dof%h(i)**d2p3/sfl
        CALL PUSHCONTROL2B(0)
      ELSE IF (friction .EQ. 2) THEN
        CALL PUSHREAL8(sfl)
        sfl = one - dt*manning(land(i))
        CALL PUSHCONTROL2B(1)
      ELSE
        CALL PUSHREAL8(sfl)
        sfl = 1._rp
        CALL PUSHCONTROL2B(2)
      END IF
      CALL PUSHREAL8(dof%u(i))
      dof%u(i) = dof%u(i)*sfl
      CALL PUSHREAL8(dof%v(i))
      dof%v(i) = dof%v(i)*sfl
      CALL PUSHCONTROL1B(0)
    END IF
  END DO
  tflux_back = 0.0_8
  DO i=mesh%nc,1,-1
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8(dof%v(i))
      CALL POPREAL8(dof%u(i))
      sfl_back = dof%v(i)*dof_back%v(i) + dof%u(i)*dof_back%u(i)
      dof_back%v(i) = sfl*dof_back%v(i)
      dof_back%u(i) = sfl*dof_back%u(i)
      CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8(sfl)
        temp_back4 = 2._rp*sfl_back/sfl
        sfl_back = -(dof%h(i)**d2p3*temp_back4/sfl)
        IF (.NOT.(dof%h(i) .LE. 0.0 .AND. (d2p3 .EQ. 0.0 .OR. d2p3 .NE. &
&           INT(d2p3)))) dof_back%h(i) = dof_back%h(i) + d2p3*dof%h(i)**&
&           (d2p3-1)*temp_back4
        CALL POPREAL8(sfl)
        temp1 = manning_beta(land(i))
        temp0 = dof%h(i)**temp1
        temp = manning(land(i))*manning(land(i))
        temp2 = 4._rp*dt*g
        IF (.NOT.(dof%h(i) .LE. 0.0 .AND. (d2p3 .EQ. 0.0 .OR. d2p3 .NE. &
&           INT(d2p3)))) dof_back%h(i) = dof_back%h(i) + d2p3*dof%h(i)**&
&           (d2p3-1)*sfl_back
        IF (dof%h(i)**d4p3 + temp2*(temp*vel*temp0**2) .EQ. 0.0) THEN
          temp_back2 = 0.0_8
        ELSE
          temp_back2 = sfl_back/(2.0*SQRT(dof%h(i)**d4p3+temp2*(temp*vel&
&           *temp0**2)))
        END IF
        IF (.NOT.(dof%h(i) .LE. 0.0 .AND. (d4p3 .EQ. 0.0 .OR. d4p3 .NE. &
&           INT(d4p3)))) dof_back%h(i) = dof_back%h(i) + d4p3*dof%h(i)**&
&           (d4p3-1)*temp_back2
        temp_back3 = temp2*temp_back2
        temp_back4 = temp0**2*temp_back3
        temp_back0 = 2*temp0*temp*vel*temp_back3
        IF (.NOT.(dof%h(i) .LE. 0.0 .AND. (temp1 .EQ. 0.0 .OR. temp1 &
&           .NE. INT(temp1)))) dof_back%h(i) = dof_back%h(i) + temp1*dof&
&           %h(i)**(temp1-1)*temp_back0
        IF (.NOT.dof%h(i) .LE. 0.0) manning_beta_back(land(i)) = &
&           manning_beta_back(land(i)) + temp0*LOG(dof%h(i))*temp_back0
        manning_back(land(i)) = manning_back(land(i)) + 2*manning(land(i&
&         ))*vel*temp_back4
        vel_back = temp*temp_back4
        CALL POPREAL8(vel)
        IF (dof%u(i)**2 + dof%v(i)**2 .EQ. 0.0) THEN
          temp_back1 = 0.0_8
        ELSE
          temp_back1 = vel_back/(2.0*SQRT(dof%u(i)**2+dof%v(i)**2))
        END IF
        dof_back%u(i) = dof_back%u(i) + 2*dof%u(i)*temp_back1
        dof_back%v(i) = dof_back%v(i) + 2*dof%v(i)*temp_back1
      ELSE IF (branch .EQ. 1) THEN
        CALL POPREAL8(sfl)
        manning_back(land(i)) = manning_back(land(i)) - dt*sfl_back
      ELSE
        CALL POPREAL8(sfl)
      END IF
      CALL POPREAL8(dof%v(i))
      temp0 = dt*mesh%cell(i)%invsurf
      temp_back1 = dof_back%v(i)/dof%h(i)
      dof_back%v(i) = 0.0_8
      h_back = v*temp_back1
      v_back = h*temp_back1
      tflux_back(3, i) = tflux_back(3, i) - temp0*temp_back1
      dof_back%h(i) = dof_back%h(i) - (h*v-temp0*tflux(3, i))*temp_back1&
&       /dof%h(i)
      CALL POPREAL8(dof%u(i))
      temp0 = dt*mesh%cell(i)%invsurf
      temp_back1 = dof_back%u(i)/dof%h(i)
      dof_back%u(i) = 0.0_8
      h_back = h_back + u*temp_back1
      u_back = h*temp_back1
      tflux_back(2, i) = tflux_back(2, i) - temp0*temp_back1
      dof_back%h(i) = dof_back%h(i) - (h*u-temp0*tflux(2, i))*temp_back1&
&       /dof%h(i)
    ELSE
      CALL POPREAL8(dof%v(i))
      dof_back%v(i) = 0.0_8
      CALL POPREAL8(dof%u(i))
      dof_back%u(i) = 0.0_8
      h_back = 0.0_8
      u_back = 0.0_8
      v_back = 0.0_8
    END IF
    CALL POPCONTROL2B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8(dof%infil(i))
      fn1_back = dof_back%infil(i)
      dof_back%infil(i) = 0.0_8
      CALL POPREAL8(dof%h(i))
      h_infil_back = dof_back%h(i)
      dof_back%h(i) = 0.0_8
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        dof_back%h(i) = dof_back%h(i) + fn1_back
        dof_back%infil(i) = dof_back%infil(i) + fn1_back
        h_infil_back = 0.0_8
        fn1_back = 0.0_8
      END IF
      fn1_back = fn1_back - h_infil_back
      IF (afn1**2._rp + 4._rp*bfn1 .EQ. 0.0) THEN
        temp_back1 = 0.0_8
      ELSE
        temp_back1 = fn1_back/(2.0*SQRT(afn1**2._rp+4._rp*bfn1)*2._rp)
      END IF
      afn1_back = fn1_back/2._rp + 2._rp*afn1*temp_back1
      bfn1_back = 4._rp*temp_back1
      temp_back0 = infil%ga(infil%land(i))%ks*infil%ga(infil%land(i))%&
&       deltatheta*dt*bfn1_back
      dof_back%h(i) = dof_back%h(i) + h_infil_back + temp_back0
      dof_back%infil(i) = dof_back%infil(i) + h_infil_back + temp_back0 &
&       + afn1_back
      CALL POPREAL8(bfn1)
      temp_back1 = (dof%infil(i)+dof%h(i)+infil%ga(infil%land(i))%psif)*&
&       dt*bfn1_back
      infil_back%ga(infil%land(i))%psif = infil_back%ga(infil%land(i))%&
&       psif + temp_back0
      infil_back%ga(infil%land(i))%ks = infil_back%ga(infil%land(i))%ks &
&       + infil%ga(infil%land(i))%deltatheta*temp_back1 + (1._rp-infil%&
&       ga(infil%land(i))%deltatheta)*dt*afn1_back
      infil_back%ga(infil%land(i))%deltatheta = infil_back%ga(infil%land&
&       (i))%deltatheta + infil%ga(infil%land(i))%ks*temp_back1 - infil%&
&       ga(infil%land(i))%ks*dt*afn1_back
      CALL POPREAL8(afn1)
    END IF
    CALL POPCONTROL2B(branch)
    IF (branch .LT. 2) THEN
      IF (branch .EQ. 0) THEN
        CALL POPREAL8(dof%infil(i))
        fn1_back = dof_back%infil(i) - dof_back%h(i)
        dof_back%infil(i) = dof_back%h(i)
        k = mesh%cell(i)%rain
        CALL POPREAL8(dof%h(i))
        bc_back%rain(k)%qin = bc_back%rain(k)%qin + dt*dof_back%h(i)
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          s = 25.4_rp*(1000._rp/abs0-10._rp)/1000._rp
          temp = bc%rain(k)%cumul + (-abs4+1)*s
          temp1 = bc%rain(k)%cumul - abs3*s
          abs2_back = s*fn1_back
          temp_back0 = fn1_back/temp
          temp_back1 = s*temp_back0
          temp_back = -(s*temp1*temp_back0/temp)
          s_back = abs2*fn1_back + temp1*temp_back0 + (1-abs4)*temp_back&
&           - abs3*temp_back1
          bc_back%rain(k)%cumul = bc_back%rain(k)%cumul + temp_back + &
&           temp_back1
          abs4_back = -(s*temp_back)
          abs3_back = -(s*temp_back1)
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREAL8(abs4)
            infil_back%scs(infil%land(i))%lambda = infil_back%scs(infil%&
&             land(i))%lambda + abs4_back
          ELSE
            CALL POPREAL8(abs4)
            infil_back%scs(infil%land(i))%lambda = infil_back%scs(infil%&
&             land(i))%lambda - abs4_back
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREAL8(abs3)
            infil_back%scs(infil%land(i))%lambda = infil_back%scs(infil%&
&             land(i))%lambda - abs3_back
          ELSE
            CALL POPREAL8(abs3)
            infil_back%scs(infil%land(i))%lambda = infil_back%scs(infil%&
&             land(i))%lambda + abs3_back
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREAL8(abs2)
            infil_back%scs(infil%land(i))%lambda = infil_back%scs(infil%&
&             land(i))%lambda - abs2_back
          ELSE
            CALL POPREAL8(abs2)
            infil_back%scs(infil%land(i))%lambda = infil_back%scs(infil%&
&             land(i))%lambda + abs2_back
          END IF
        ELSE
          dof_back%infil(i) = dof_back%infil(i) + fn1_back
          bc_back%rain(k)%qin = bc_back%rain(k)%qin + dt*fn1_back
          s_back = 0.0_8
        END IF
        abs0_back = -(25.4_rp*s_back/abs0**2)
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8(abs0)
          infil_back%scs(infil%land(i))%cn = infil_back%scs(infil%land(i&
&           ))%cn + abs0_back
        ELSE
          CALL POPREAL8(abs0)
          infil_back%scs(infil%land(i))%cn = infil_back%scs(infil%land(i&
&           ))%cn - abs0_back
        END IF
      ELSE
        k = mesh%cell(i)%rain
        CALL POPREAL8(dof%h(i))
        bc_back%rain(k)%qin = bc_back%rain(k)%qin + dt*dof_back%h(i)
      END IF
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8(dof%h(i))
      h_back = h_back + dof_back%h(i)
      tflux_back(1, i) = tflux_back(1, i) - dt*mesh%cell(i)%invsurf*&
&       dof_back%h(i)
      dof_back%h(i) = 0.0_8
    ELSE
      CALL POPREAL8(dof%h(i))
      dof_back%h(i) = 0.0_8
    END IF
    CALL POPREAL8(v)
    dof_back%v(i) = dof_back%v(i) + v_back
    CALL POPREAL8(u)
    dof_back%u(i) = dof_back%u(i) + u_back
    CALL POPREAL8(h)
    dof_back%h(i) = dof_back%h(i) + h_back
  END DO
  DO k=bc%nb_rn,1,-1
    bc_back%rain(k)%qin = bc_back%rain(k)%qin + dt*bc_back%rain(k)%cumul
  END DO
  nflux_back = 0.0_8
  hl_back = 0.0_8
  ul_back = 0.0_8
  hr_back = 0.0_8
  ur_back = 0.0_8
  vl_back = 0.0_8
  vr_back = 0.0_8
  lflux_back = 0.0_8
  DO ie=mesh%ne,1,-1
    CALL POPCONTROL3B(branch)
    IF (branch .LT. 2) THEN
      IF (branch .EQ. 0) GOTO 110
    ELSE
      IF (branch .NE. 2) THEN
        IF (branch .NE. 3) THEN
          temp_back = -(mesh%edge(ie)%normal%y*mesh%edge(ie)%length*g*&
&           0.5_rp*tflux_back(3, ir))
          hr_back(1) = hr_back(1) + 2*hr(1)*temp_back
          hr_back(2) = hr_back(2) - 2*hr(2)*temp_back
          temp_back = -(mesh%edge(ie)%normal%x*mesh%edge(ie)%length*g*&
&           0.5_rp*tflux_back(2, ir))
          hr_back(1) = hr_back(1) + 2*hr(1)*temp_back
          hr_back(2) = hr_back(2) - 2*hr(2)*temp_back
          lflux_back(3) = lflux_back(3) - tflux_back(3, ir)
          lflux_back(2) = lflux_back(2) - tflux_back(2, ir)
          lflux_back(1) = lflux_back(1) - tflux_back(1, ir)
        END IF
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        temp_back = -(mesh%edge(ie)%normal%y*mesh%edge(ie)%length*g*&
&         0.5_rp*tflux_back(3, ir))
        hr_back(1) = hr_back(1) + 2*hr(1)*temp_back
        hr_back(2) = hr_back(2) - 2*hr(2)*temp_back
        temp_back = -(mesh%edge(ie)%normal%x*mesh%edge(ie)%length*g*&
&         0.5_rp*tflux_back(2, ir))
        hr_back(1) = hr_back(1) + 2*hr(1)*temp_back
        hr_back(2) = hr_back(2) - 2*hr(2)*temp_back
        lflux_back(3) = lflux_back(3) - tflux_back(3, ir)
        lflux_back(2) = lflux_back(2) - tflux_back(2, ir)
        lflux_back(1) = lflux_back(1) - tflux_back(1, ir)
      END IF
      il = mesh%edge(ie)%cell(1)
      temp_back = mesh%edge(ie)%normal%y*mesh%edge(ie)%length*g*0.5_rp*&
&       tflux_back(3, il)
      hl_back(1) = hl_back(1) + 2*hl(1)*temp_back
      hl_back(2) = hl_back(2) - 2*hl(2)*temp_back
      temp_back = mesh%edge(ie)%normal%x*mesh%edge(ie)%length*g*0.5_rp*&
&       tflux_back(2, il)
      hl_back(1) = hl_back(1) + 2*hl(1)*temp_back
      hl_back(2) = hl_back(2) - 2*hl(2)*temp_back
      lflux_back(3) = lflux_back(3) + tflux_back(3, il)
      lflux_back(2) = lflux_back(2) + tflux_back(2, il)
      lflux_back(1) = lflux_back(1) + tflux_back(1, il)
      lflux_back(1:3) = mesh%edge(ie)%length*lflux_back(1:3)
      nflux_back(2) = nflux_back(2) + mesh%edge(ie)%normal%y*lflux_back(&
&       3) + mesh%edge(ie)%normal%x*lflux_back(2)
      nflux_back(3) = nflux_back(3) + mesh%edge(ie)%normal%x*lflux_back(&
&       3) - mesh%edge(ie)%normal%y*lflux_back(2)
      lflux_back(3) = 0.0_8
      lflux_back(2) = 0.0_8
      nflux_back(1) = nflux_back(1) + lflux_back(1)
      lflux_back(1) = 0.0_8
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8ARRAY(bc%sum_mass_flux, SIZE(bc%sum_mass_flux, 1))
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 1) CALL POPREAL8ARRAY(bathy_cell, SIZE(&
&                                       bathy_cell, 1))
        CALL BOUNDARY_POST_BACK(nflux(1), nflux_back(1), ir, mesh)
      END IF
      CALL POPREAL8ARRAY(nflux, 3)
      CALL SW_HLLC_BACK(hl(2), hl_back(2), ul(2), ul_back(2), vl(2), &
&                 vl_back(2), hr(2), hr_back(2), ur(2), ur_back(2), vr(2&
&                 ), vr_back(2), nflux, nflux_back)
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8(hr(2))
        y2_back = hr_back(2)
        hr_back(2) = 0.0_8
      ELSE
        CALL POPREAL8(hr(2))
        hr_back(2) = 0.0_8
        y2_back = 0.0_8
      END IF
      hr_back(1) = hr_back(1) + y2_back
      zr_back = y2_back
      max2_back = -y2_back
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        zr_back = zr_back + max2_back
        zl_back = 0.0_8
      ELSE
        zl_back = max2_back
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8(hl(2))
        y1_back = hl_back(2)
        hl_back(2) = 0.0_8
      ELSE
        CALL POPREAL8(hl(2))
        hl_back(2) = 0.0_8
        y1_back = 0.0_8
      END IF
      hl_back(1) = hl_back(1) + y1_back
      zl_back = zl_back + y1_back
      max1_back = -y1_back
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        zr_back = zr_back + max1_back
      ELSE
        zl_back = zl_back + max1_back
      END IF
      CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8(hr(1))
        CALL POPREAL8(ur(2))
        CALL POPREAL8(vr(2))
        CALL CALC_BOUNDARY_STATE_BACK(mesh, hl(1), hl_back(1), zl, &
&                               zl_back, ul(2), ul_back(2), vl(2), &
&                               vl_back(2), hr(1), hr_back(1), zr, &
&                               zr_back, ur(2), ur_back(2), vr(2), &
&                               vr_back(2))
        hr_back(1) = 0.0_8
        ur_back(2) = 0.0_8
        vr_back(2) = 0.0_8
      ELSE IF (branch .EQ. 1) THEN
        CALL POPREAL8(vr(2))
        vr_back(1) = vr_back(1) + mesh%edge(ie)%normal%x*vr_back(2) + &
&         mesh%edge(ie)%normal%y*ur_back(2)
        ur_back(1) = ur_back(1) + mesh%edge(ie)%normal%x*ur_back(2) - &
&         mesh%edge(ie)%normal%y*vr_back(2)
        vr_back(2) = 0.0_8
        CALL POPREAL8(ur(2))
        ur_back(2) = 0.0_8
        CALL POPREAL8(vr(1))
        dof_back%v(ir) = dof_back%v(ir) + vr_back(1)
        vr_back(1) = 0.0_8
        CALL POPREAL8(ur(1))
        dof_back%u(ir) = dof_back%u(ir) + ur_back(1)
        ur_back(1) = 0.0_8
      ELSE
        CALL POPREAL8(vr(2))
        vr_back(1) = vr_back(1) + mesh%edge(ie)%normal%x*vr_back(2) + &
&         mesh%edge(ie)%normal%y*ur_back(2)
        ur_back(1) = ur_back(1) + mesh%edge(ie)%normal%x*ur_back(2) - &
&         mesh%edge(ie)%normal%y*vr_back(2)
        vr_back(2) = 0.0_8
        CALL POPREAL8(ur(2))
        ur_back(2) = 0.0_8
        CALL POPREAL8(vr(1))
        dof_back%v(ir) = dof_back%v(ir) + vr_back(1)
        vr_back(1) = 0.0_8
        CALL POPREAL8(ur(1))
        dof_back%u(ir) = dof_back%u(ir) + ur_back(1)
        ur_back(1) = 0.0_8
      END IF
      CALL POPREAL8(vl(2))
      vl_back(1) = vl_back(1) + mesh%edge(ie)%normal%x*vl_back(2) + mesh&
&       %edge(ie)%normal%y*ul_back(2)
      ul_back(1) = ul_back(1) + mesh%edge(ie)%normal%x*ul_back(2) - mesh&
&       %edge(ie)%normal%y*vl_back(2)
      vl_back(2) = 0.0_8
      CALL POPREAL8(ul(2))
      ul_back(2) = 0.0_8
      CALL POPREAL8(vl(1))
      dof_back%v(il) = dof_back%v(il) + vl_back(1)
      vl_back(1) = 0.0_8
      CALL POPREAL8(ul(1))
      dof_back%u(il) = dof_back%u(il) + ul_back(1)
      ul_back(1) = 0.0_8
      bathy_cell_back(ir) = bathy_cell_back(ir) + zr_back
      bathy_cell_back(il) = bathy_cell_back(il) + zl_back
    END IF
    CALL POPREAL8(hr(1))
    dof_back%h(ir) = dof_back%h(ir) + hr_back(1)
    hr_back(1) = 0.0_8
    CALL POPREAL8(hl(1))
    dof_back%h(il) = dof_back%h(il) + hl_back(1)
    hl_back(1) = 0.0_8
    CALL POPCONTROL1B(branch)
 110 CALL POPINTEGER4(ir)
    CALL POPINTEGER4(il)
  END DO
END SUBROUTINE EULER_TIME_STEP_FIRST_B1_BACK

