!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (master) -  9 Oct 2020 17:47
!
!  Differentiation of calc_boundary_state in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: *(bc.inflow) *(bc.outflow)
!                *bathy_cell hl ul hr ur vl vr zl zr
!   with respect to varying inputs: *(bc.inflow) *(bc.outflow)
!                *bathy_cell hl ul vl zl zr
!   Plus diff mem management of: bc.inflow:in bc.outflow:in bc.hpresc:in
!                *(bc.hpresc).t:in *(bc.hpresc).h:in bc.zspresc:in
!                *(bc.zspresc).t:in *(bc.zspresc).z:in bathy_cell:in
SUBROUTINE CALC_BOUNDARY_STATE_BACK(mesh, hl, hl_back, zl, zl_back, ul, &
& ul_back, vl, vl_back, hr, hr_back, zr, zr_back, ur, ur_back, vr, &
& vr_back)
! add lilian for linear interp
  USE M_NUMERIC ! Replaced by Perl Script
  USE M_NUMERIC_BACK
  USE M_MODEL ! Replaced by Perl Script

  USE M_TAP_VARS ! Added by Perl Script -> Need to be filled !!!

  IMPLICIT NONE
  TYPE(MSH), INTENT(IN) :: mesh
  REAL(rp), INTENT(IN) :: hl, ul, vl, zl, zr
  REAL(rp) :: hl_back, ul_back, vl_back, zl_back, zr_back
  REAL(rp) :: hr, ur, vr
  REAL(rp) :: hr_back, ur_back, vr_back
  INTRINSIC SQRT
  INTRINSIC MAX
  REAL(rp) :: y1
  REAL(rp) :: y1_back
  REAL(rp) :: result1
  REAL(rp) :: temp_back
  INTEGER :: branch
  ib = mesh%edge(ie)%lim
  SELECT CASE  (mesh%edgeb(ib)%typlim) 
  CASE ('neumann') 
    vl_back = vl_back + vr_back
    ul_back = ul_back + ur_back
    hl_back = hl_back + hr_back
  CASE ('wall') 
    vl_back = vl_back + vr_back
    ul_back = ul_back - ur_back
    hl_back = hl_back + hr_back
    zl_back = zl_back + hr_back
    zr_back = zr_back - hr_back
  CASE ('discharg1') 
    vl_back = vl_back + vr_back
    bc_back%inflow(ib) = bc_back%inflow(ib) + ur_back
    hl_back = hl_back + hr_back
  CASE ('discharg2') 
    CALL PUSHREAL8(hr)
    hr = bc%inflow(ib)
    vl_back = vl_back + vr_back
    ul_back = ul_back + ur_back
    temp_back = two*SQRT(g)*ur_back
    IF (.NOT.hl .EQ. 0.0) hl_back = hl_back + temp_back/(2.0*SQRT(hl))
    IF (.NOT.hr .EQ. 0.0) hr_back = hr_back - temp_back/(2.0*SQRT(hr))
    CALL POPREAL8(hr)
    bc_back%inflow(ib) = bc_back%inflow(ib) + hr_back
  CASE ('transm') 
    IF (ul .GT. SQRT(g*hl)) THEN
      CALL PUSHCONTROL2B(0)
    ELSE IF (ul .GT. 0._rp .AND. hl .GT. heps) THEN
      CALL PUSHCONTROL2B(1)
    ELSE
      CALL PUSHCONTROL2B(2)
    END IF
    vl_back = vl_back + vr_back
    CALL POPCONTROL2B(branch)
    IF (branch .EQ. 0) THEN
      ul_back = ul_back + ur_back
      hl_back = hl_back + hr_back
    ELSE IF (branch .EQ. 1) THEN
      ul_back = ul_back + ur_back
      hl_back = hl_back + hr_back
    ELSE
      ul_back = ul_back - ur_back
      hl_back = hl_back + hr_back
    END IF
  CASE ('ratcurve') 
    vl_back = vl_back + vr_back
    bc_back%outflow(mesh%neb+ib) = bc_back%outflow(mesh%neb+ib) + &
&     ur_back
    bc_back%outflow(ib) = bc_back%outflow(ib) + hr_back
  CASE ('zspresc') 
    result1 = LINEAR_INTERP(bc%zspresc(1)%t, bc%zspresc(1)%z, tc)
    y1 = result1 - bathy_cell(mesh%edge(ie)%cell(2))
    IF (0._rp .LT. y1) THEN
      CALL PUSHREAL8(hr)
      hr = y1
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHREAL8(hr)
      hr = 0._rp
      CALL PUSHCONTROL1B(1)
    END IF
    vl_back = vl_back + vr_back
    ul_back = ul_back + ur_back
    temp_back = two*SQRT(g)*ur_back
    IF (.NOT.hl .EQ. 0.0) hl_back = hl_back + temp_back/(2.0*SQRT(hl))
    IF (.NOT.hr .EQ. 0.0) hr_back = hr_back - temp_back/(2.0*SQRT(hr))
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8(hr)
      y1_back = hr_back
    ELSE
      CALL POPREAL8(hr)
      y1_back = 0.0_8
    END IF
    bathy_cell_back(mesh%edge(ie)%cell(2)) = bathy_cell_back(mesh%edge(&
&     ie)%cell(2)) - y1_back
  CASE ('hpresc') 
    vl_back = vl_back + vr_back
    ul_back = ul_back + ur_back
    IF (.NOT.hl .EQ. 0.0) hl_back = hl_back + two*SQRT(g)*ur_back/(2.0*&
&       SQRT(hl))
  CASE DEFAULT
    vl_back = vl_back + vr_back
    ul_back = ul_back - ur_back
    hl_back = hl_back + hr_back
    zl_back = zl_back + hr_back
    zr_back = zr_back - hr_back
  END SELECT
END SUBROUTINE CALC_BOUNDARY_STATE_BACK

