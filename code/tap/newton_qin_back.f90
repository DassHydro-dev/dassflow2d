!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (master) -  9 Oct 2020 17:47
!
!  Differentiation of newton_qin in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: *bathy_cell *(dof.h) *(dof.u)
!                *(dof.v) qin zs
!   with respect to varying inputs: *bathy_cell *(dof.h) *(dof.u)
!                *(dof.v) qin
!   Plus diff mem management of: bathy_cell:in dof.h:in dof.u:in
!                dof.v:in
SUBROUTINE NEWTON_QIN_BACK(qin, qin_back, dof, dof_back, mesh, zs, &
& zs_back)
  USE M_MODEL ! Replaced by Perl Script

  USE M_TAP_VARS ! Added by Perl Script -> Need to be filled !!!

  IMPLICIT NONE
  TYPE(MSH), INTENT(IN) :: mesh
  TYPE(UNK), INTENT(IN) :: dof
  TYPE(UNK) :: dof_back
  REAL(rp), INTENT(IN) :: qin
  REAL(rp) :: qin_back
  REAL(rp) :: zs
  REAL(rp) :: zs_back
  INTEGER(ip) :: av
  REAL(rp) :: r, c, z, dzs, s1, s2
  REAL(rp) :: r_back, z_back, s1_back, s2_back
  INTRINSIC SQRT
  INTRINSIC REAL
  INTRINSIC MAX
  INTRINSIC ABS
  REAL(rp) :: temp_back
  REAL(rp) :: temp
  REAL(rp) :: temp_back0
  INTEGER :: branch
  INTEGER :: ad_count
  INTEGER :: i0
  c = two*SQRT(g)
  zs = zero
  av = 0
  CALL PUSHINTEGER4(ie)
  DO ie=1,mesh%neb
    IF (mesh%edgeb(ie)%typlim(1:8) .EQ. 'discharg') THEN
      i = mesh%edge(mesh%edgeb(ie)%ind)%cell(1)
      IF (dof%h(i) .GT. heps) THEN
        av = av + 1
        zs = zs + bathy_cell(i) + dof%h(i)
        CALL PUSHCONTROL2B(2)
      ELSE
        CALL PUSHCONTROL2B(1)
      END IF
    ELSE
      CALL PUSHCONTROL2B(0)
    END IF
  END DO
  IF (av .GT. 0) THEN
    zs = zs/REAL(av, rp)
    CALL PUSHCONTROL1B(0)
  ELSE
    zs = zero
    CALL PUSHCONTROL1B(1)
  END IF
  dzs = one
  k = 0
  ad_count = 0
  DO WHILE (k .LE. 50 .AND. dzs .GT. 10._rp*zerom)
    dzs = zs
    CALL PUSHREAL8(s1)
    s1 = zero
    CALL PUSHREAL8(s2)
    s2 = zero
    DO ie=1,mesh%neb
      IF (mesh%edgeb(ie)%typlim(1:8) .EQ. 'discharg') THEN
        i = mesh%edge(mesh%edgeb(ie)%ind)%cell(1)
        IF (dof%h(i) .GT. heps) THEN
          CALL PUSHREAL8(r)
          r = dof%u(i)*mesh%edge(mesh%edgeb(ie)%ind)%normal%x + dof%v(i)&
&           *mesh%edge(mesh%edgeb(ie)%ind)%normal%y + c*SQRT(dof%h(i))
          IF (zero .LT. zs - bathy_cell(i)) THEN
            CALL PUSHREAL8(z)
            z = zs - bathy_cell(i)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHREAL8(z)
            z = zero
            CALL PUSHCONTROL1B(1)
          END IF
          s1 = s1 - z*(r-c*SQRT(z))*mesh%edge(mesh%edgeb(ie)%ind)%length
          s2 = s2 - (r-d3p2*c*SQRT(z))*mesh%edge(mesh%edgeb(ie)%ind)%&
&           length
          CALL PUSHCONTROL2B(2)
        ELSE
          CALL PUSHCONTROL2B(1)
        END IF
      ELSE
        CALL PUSHCONTROL2B(0)
      END IF
    END DO
    zs = zs - (s1-qin)/s2
    IF (1._rp - dzs/zs .GE. 0.) THEN
      dzs = 1._rp - dzs/zs
    ELSE
      dzs = -(1._rp-dzs/zs)
    END IF
    k = k + 1
    ad_count = ad_count + 1
  END DO
  DO i0=1,ad_count
    temp_back0 = -(zs_back/s2)
    s1_back = temp_back0
    qin_back = qin_back - temp_back0
    s2_back = -((s1-qin)*temp_back0/s2)
    DO ie=mesh%neb,1,-1
      CALL POPCONTROL2B(branch)
      IF (branch .NE. 0) THEN
        IF (branch .NE. 1) THEN
          temp_back = -(mesh%edge(mesh%edgeb(ie)%ind)%length*s1_back)
          temp_back0 = -(mesh%edge(mesh%edgeb(ie)%ind)%length*s2_back)
          r_back = temp_back0 + z*temp_back
          IF (z .EQ. 0.0) THEN
            z_back = 0.0_8
          ELSE
            z_back = -(d3p2*c*temp_back0/(2.0*SQRT(z)))
          END IF
          temp = SQRT(z)
          IF (z .EQ. 0.0) THEN
            z_back = z_back + (r-c*temp)*temp_back
          ELSE
            z_back = z_back + (r-c*temp-c*z/(2.0*temp))*temp_back
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            i = mesh%edge(mesh%edgeb(ie)%ind)%cell(1)
            CALL POPREAL8(z)
            zs_back = zs_back + z_back
            bathy_cell_back(i) = bathy_cell_back(i) - z_back
          ELSE
            CALL POPREAL8(z)
            i = mesh%edge(mesh%edgeb(ie)%ind)%cell(1)
          END IF
          CALL POPREAL8(r)
          dof_back%u(i) = dof_back%u(i) + mesh%edge(mesh%edgeb(ie)%ind)%&
&           normal%x*r_back
          dof_back%v(i) = dof_back%v(i) + mesh%edge(mesh%edgeb(ie)%ind)%&
&           normal%y*r_back
          IF (.NOT.dof%h(i) .EQ. 0.0) dof_back%h(i) = dof_back%h(i) + c*&
&             r_back/(2.0*SQRT(dof%h(i)))
        END IF
      END IF
    END DO
    CALL POPREAL8(s2)
    CALL POPREAL8(s1)
  END DO
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    zs_back = zs_back/REAL(av, rp)
  ELSE
    zs_back = 0.0_8
  END IF
  DO ie=mesh%neb,1,-1
    CALL POPCONTROL2B(branch)
    IF (branch .NE. 0) THEN
      IF (branch .NE. 1) THEN
        i = mesh%edge(mesh%edgeb(ie)%ind)%cell(1)
        bathy_cell_back(i) = bathy_cell_back(i) + zs_back
        dof_back%h(i) = dof_back%h(i) + zs_back
      END IF
    END IF
  END DO
  CALL POPINTEGER4(ie)
END SUBROUTINE NEWTON_QIN_BACK

