!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (master) -  9 Oct 2020 17:47
!
!  Differentiation of run_model in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: *(*innovation.diff) *(dof.h)
!                *(dof.u) *(dof.v) cost
!   with respect to varying inputs: *(infil.ga).psif *(infil.ga).ks
!                *(infil.ga).deltatheta *(infil.scs).lambda *(infil.scs).cn
!                *manning *(*(bc.hyd).t) *(*(bc.hyd).q) *(*(bc.rat).h)
!                *(*(bc.rat).q) *(*(bc.rain).t) *(*(bc.rain).q)
!                *bathy_cell *manning_beta *(dof0.h) *(dof0.u)
!                *(dof0.v)
!   RW status of diff variables: tc:(loc) *(infil.ga).psif:out
!                *(infil.ga).ks:out *(infil.ga).deltatheta:out
!                *(infil.scs).lambda:out *(infil.scs).cn:out *manning:out
!                *(bc.inflow):(loc) *(bc.outflow):(loc) *(*(bc.hyd).t):out
!                *(*(bc.hyd).q):out *(*(bc.rat).h):out *(*(bc.rat).q):out
!                *(bc.rat).zout:(loc) *(*(bc.rain).t):out *(*(bc.rain).q):out
!                *(bc.rain).qin:(loc) *(bc.rain).cumul:(loc) *(bc.sum_mass_flux):(loc)
!                *bathy_cell:out *manning_beta:out *(*innovation.diff):in-killed
!                dof.h:(loc) *(dof.h):in-killed dof.u:(loc) *(dof.u):in-killed
!                dof.v:(loc) *(dof.v):in-killed *(dof.infil):(loc)
!                cost:in-killed dof0.h:(loc) *(dof0.h):out dof0.u:(loc)
!                *(dof0.u):out dof0.v:(loc) *(dof0.v):out
!   Plus diff mem management of: infil.ga:in infil.scs:in manning:in
!                bc.inflow:in bc.outflow:in bc.hyd:in *(bc.hyd).t:in
!                *(bc.hyd).q:in bc.rat:in *(bc.rat).h:in *(bc.rat).q:in
!                bc.hpresc:in *(bc.hpresc).t:in *(bc.hpresc).h:in
!                bc.zspresc:in *(bc.zspresc).t:in *(bc.zspresc).z:in
!                bc.rain:in *(bc.rain).t:in *(bc.rain).q:in bc.sum_mass_flux:in
!                bathy_cell:in manning_beta:in innovation:in *innovation.diff:in
!                dof.h:in dof.u:in dof.v:in dof.infil:in dof0.h:in
!                dof0.u:in dof0.v:in
SUBROUTINE RUN_MODEL_BACK(mesh, dof0, dof0_back, dof, dof_back, cost, &
& cost_back)
  USE M_COMMON ! Replaced by Perl Script
  USE M_LINEAR_ALGEBRA ! Replaced by Perl Script
  USE M_MESH ! Replaced by Perl Script
  USE M_NUMERIC ! Replaced by Perl Script
  USE M_NUMERIC_BACK
  USE M_MODEL ! Replaced by Perl Script
  USE M_OBS ! Replaced by Perl Script
  USE M_OBS_BACK

  USE M_TAP_VARS ! Added by Perl Script -> Need to be filled !!!

  IMPLICIT NONE
  TYPE(MSH), INTENT(INOUT) :: mesh
  TYPE(UNK), INTENT(IN) :: dof0
  TYPE(UNK) :: dof0_back
  TYPE(UNK), INTENT(INOUT) :: dof
  TYPE(UNK), INTENT(INOUT) :: dof_back
  REAL(rp) :: cost
  REAL(rp) :: cost_back
  INTEGER(ip) :: sub_nt
  INTEGER :: branch
  INTEGER :: ad_count
  INTEGER :: i0
  INTEGER :: ii1
  dof%h = dof0%h
  dof%u = dof0%u
  dof%v = dof0%v
  tc = tc0
  nt = nt0
  IF (use_obs .EQ. 1) innovation(:)%ind_t = 1_ip
  cost = 0._rp
  end_time_loop = .false.
  ad_count = 0
  DO WHILE (.NOT.end_time_loop)
    CALL PUSHREAL8ARRAY(dof%infil, SIZE(dof%infil, 1))
    CALL PUSHREAL8ARRAY(dof%v, SIZE(dof%v, 1))
    CALL PUSHREAL8ARRAY(dof%u, SIZE(dof%u, 1))
    CALL PUSHREAL8ARRAY(dof%h, SIZE(dof%h, 1))
    IF (ALLOCATED(innovation)) THEN
      CALL PUSHINTEGER4ARRAY(innovation%ind_t, SIZE(innovation, 1))
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
    IF (ALLOCATED(bathy_cell)) THEN
      CALL PUSHREAL8ARRAY(bathy_cell, SIZE(bathy_cell, 1))
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
    CALL PUSHREAL8ARRAY(bc%sum_mass_flux, SIZE(bc%sum_mass_flux, 1))
    CALL PUSHREAL8ARRAY(bc%rain%cumul, SIZE(bc%rain, 1))
    CALL PUSHREAL8ARRAY(bc%rain%qin, SIZE(bc%rain, 1))
    CALL PUSHREAL8ARRAY(bc%rat%zout, SIZE(bc%rat, 1))
    CALL PUSHREAL8ARRAY(bc%outflow, SIZE(bc%outflow, 1))
    CALL PUSHREAL8ARRAY(bc%inflow, SIZE(bc%inflow, 1))
    CALL PUSHREAL8(tc)
    CALL PUSHBOOLEAN(end_time_loop)
    CALL PUSHINTEGER4(nt)
    CALL PUSHREAL8(dt)
    CALL SUB_RUN_MODEL()
    ad_count = ad_count + 1
  END DO
  CALL PUSHINTEGER4(ad_count)
  CALL CALC_COST_FUNCTION_BACK(cost, cost_back, mesh)
  infil_back%ga%psif = 0.0_8
  infil_back%ga%ks = 0.0_8
  infil_back%ga%deltatheta = 0.0_8
  infil_back%scs%lambda = 0.0_8
  infil_back%scs%cn = 0.0_8
  IF (ALLOCATED(manning_back)) manning_back = 0.0_8
  bc_back%inflow = 0.0_8
  bc_back%outflow = 0.0_8
  DO ii1=1,SIZE(bc_back%hyd(ii1)%t, 1)
    bc_back%hyd(ii1)%t = 0.0_8
  END DO
  DO ii1=1,SIZE(bc_back%rat(ii1)%h, 1)
    bc_back%rat(ii1)%h = 0.0_8
  END DO
  DO ii1=1,SIZE(bc_back%rat(ii1)%q, 1)
    bc_back%rat(ii1)%q = 0.0_8
  END DO
  bc_back%rat%zout = 0.0_8
  DO ii1=1,SIZE(bc_back%rain(ii1)%t, 1)
    bc_back%rain(ii1)%t = 0.0_8
  END DO
  DO ii1=1,SIZE(bc_back%rain(ii1)%q, 1)
    bc_back%rain(ii1)%q = 0.0_8
  END DO
  bc_back%rain%qin = 0.0_8
  bc_back%rain%cumul = 0.0_8
  bc_back%sum_mass_flux = 0.0_8
  IF (ALLOCATED(bathy_cell_back)) bathy_cell_back = 0.0_8
  IF (ALLOCATED(manning_beta_back)) manning_beta_back = 0.0_8
  dof_back%infil = 0.0_8
  CALL POPINTEGER4(ad_count)
  DO i0=1,ad_count
    CALL POPREAL8(dt)
    CALL POPINTEGER4(nt)
    CALL POPBOOLEAN(end_time_loop)
    CALL POPREAL8(tc)
    CALL POPREAL8ARRAY(bc%inflow, SIZE(bc%inflow, 1))
    CALL POPREAL8ARRAY(bc%outflow, SIZE(bc%outflow, 1))
    CALL POPREAL8ARRAY(bc%rat%zout, SIZE(bc%rat, 1))
    CALL POPREAL8ARRAY(bc%rain%qin, SIZE(bc%rain, 1))
    CALL POPREAL8ARRAY(bc%rain%cumul, SIZE(bc%rain, 1))
    CALL POPREAL8ARRAY(bc%sum_mass_flux, SIZE(bc%sum_mass_flux, 1))
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 1) CALL POPREAL8ARRAY(bathy_cell, SIZE(bathy_cell, 1&
&                                   ))
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 1) CALL POPINTEGER4ARRAY(innovation%ind_t, SIZE(&
&                                      innovation, 1))
    CALL POPREAL8ARRAY(dof%h, SIZE(dof%h, 1))
    CALL POPREAL8ARRAY(dof%u, SIZE(dof%u, 1))
    CALL POPREAL8ARRAY(dof%v, SIZE(dof%v, 1))
    CALL POPREAL8ARRAY(dof%infil, SIZE(dof%infil, 1))
    CALL SUB_RUN_MODEL_BACK()
  END DO
  dof0_back%v = 0.0_8
  dof0_back%v = dof0_back%v + dof_back%v
  dof0_back%u = 0.0_8
  dof0_back%u = dof0_back%u + dof_back%u
  dof0_back%h = 0.0_8
  dof0_back%h = dof0_back%h + dof_back%h

CONTAINS
!  Differentiation of sub_run_model in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: *(infil.ga).psif *(infil.ga).ks
!                *(infil.ga).deltatheta *(infil.scs).lambda *(infil.scs).cn
!                *manning *(bc.inflow) *(bc.outflow) *(*(bc.hyd).t)
!                *(*(bc.hyd).q) *(*(bc.rat).h) *(*(bc.rat).q) *(bc.rat).zout
!                *(*(bc.rain).t) *(*(bc.rain).q) *(bc.rain).qin
!                *(bc.rain).cumul *(bc.sum_mass_flux) *bathy_cell
!                *manning_beta *(*innovation.diff) *(dof.h) *(dof.u)
!                *(dof.v) *(dof.infil) cost
!   with respect to varying inputs: *(infil.ga).psif *(infil.ga).ks
!                *(infil.ga).deltatheta *(infil.scs).lambda *(infil.scs).cn
!                *manning *(bc.inflow) *(bc.outflow) *(*(bc.hyd).t)
!                *(*(bc.hyd).q) *(*(bc.rat).h) *(*(bc.rat).q) *(bc.rat).zout
!                *(*(bc.rain).t) *(*(bc.rain).q) *(bc.rain).qin
!                *(bc.rain).cumul *(bc.sum_mass_flux) *bathy_cell
!                *manning_beta *(*innovation.diff) *(dof.h) *(dof.u)
!                *(dof.v) *(dof.infil) cost
!   Plus diff mem management of: infil.ga:in infil.scs:in manning:in
!                bc.inflow:in bc.outflow:in bc.hyd:in *(bc.hyd).t:in
!                *(bc.hyd).q:in bc.rat:in *(bc.rat).h:in *(bc.rat).q:in
!                bc.hpresc:in *(bc.hpresc).t:in *(bc.hpresc).h:in
!                bc.zspresc:in *(bc.zspresc).t:in *(bc.zspresc).z:in
!                bc.rain:in *(bc.rain).t:in *(bc.rain).q:in bc.sum_mass_flux:in
!                bathy_cell:in manning_beta:in innovation:in *innovation.diff:in
!                dof.h:in dof.u:in dof.v:in dof.infil:in
  SUBROUTINE SUB_RUN_MODEL_BACK()

  USE M_TAP_VARS ! Added by Perl Script -> Need to be filled !!!

    IMPLICIT NONE
    INTEGER :: branch
    INTEGER :: ad_count
    INTEGER :: i0
    sub_nt = 0
    ad_count = 0
    DO WHILE (.NOT.end_time_loop .AND. sub_nt .LT. max_nt_for_adjoint)
      CALL PUSHREAL8ARRAY(bc%rain%qin, SIZE(bc%rain, 1))
      CALL PUSHREAL8ARRAY(bc%rat%zout, SIZE(bc%rat, 1))
      CALL PUSHREAL8ARRAY(bc%outflow, SIZE(bc%outflow, 1))
      CALL PUSHREAL8ARRAY(bc%inflow, SIZE(bc%inflow, 1))
      CALL SET_BC(dof, mesh) ! Replaced by Perl Script
      CALL PUSHREAL8(tc)
      CALL PUSHINTEGER4(nt)
      CALL PUSHREAL8(dt)
      CALL ADVANCE_TIME(dof, mesh) ! Replaced by Perl Script
      CALL PUSHREAL8ARRAY(bc%sum_mass_flux, SIZE(bc%sum_mass_flux, 1))
      bc%sum_mass_flux(:) = 0._rp
      SELECT CASE  (temp_scheme) 
      CASE ('euler') 
        SELECT CASE  (spatial_scheme) 
        CASE ('first_b1') 
          IF (ALLOCATED(bathy_cell)) THEN
            CALL PUSHREAL8ARRAY(bathy_cell, SIZE(bathy_cell, 1))
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
          CALL PUSHREAL8ARRAY(bc%sum_mass_flux, SIZE(bc%sum_mass_flux, 1&
&                       ))
          CALL PUSHREAL8ARRAY(bc%rain%cumul, SIZE(bc%rain, 1))
          CALL PUSHREAL8ARRAY(dof%h, SIZE(dof%h, 1))
          CALL PUSHREAL8ARRAY(dof%u, SIZE(dof%u, 1))
          CALL PUSHREAL8ARRAY(dof%v, SIZE(dof%v, 1))
          CALL PUSHREAL8ARRAY(dof%infil, SIZE(dof%infil, 1))
          CALL EULER_TIME_STEP_FIRST_B1(dof, mesh) ! Replaced by Perl Script
          CALL PUSHCONTROL2B(0)
        CASE DEFAULT
          CALL PUSHCONTROL2B(1)
        END SELECT
      CASE DEFAULT
        CALL PUSHCONTROL2B(2)
      END SELECT
      CALL PUSHREAL8ARRAY(bc%sum_mass_flux, SIZE(bc%sum_mass_flux, 1))
      CALL SW_POST_TREATMENT(dof, mesh) ! Replaced by Perl Script
      IF (use_obs .EQ. 1) THEN
        IF (ALLOCATED(innovation)) THEN
          CALL PUSHINTEGER4ARRAY(innovation%ind_t, SIZE(innovation, 1))
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
        CALL CALC_INNOVATION(dof, mesh) ! Replaced by Perl Script
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      IF (.NOT.use_obs .EQ. 1) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      sub_nt = sub_nt + 1
      ad_count = ad_count + 1
    END DO
    DO i0=1,ad_count
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) CALL UPDATE_COST_FUNCTION_BACK(dof, dof_back, &
&                                                 cost, cost_back)
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 1) CALL POPINTEGER4ARRAY(innovation%ind_t, SIZE(&
&                                          innovation, 1))
        CALL CALC_INNOVATION_BACK(dof, dof_back, mesh)
      END IF
      CALL POPREAL8ARRAY(bc%sum_mass_flux, SIZE(bc%sum_mass_flux, 1))
      CALL SW_POST_TREATMENT_BACK(dof, mesh)
      CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8ARRAY(dof%infil, SIZE(dof%infil, 1))
        CALL POPREAL8ARRAY(dof%v, SIZE(dof%v, 1))
        CALL POPREAL8ARRAY(dof%u, SIZE(dof%u, 1))
        CALL POPREAL8ARRAY(dof%h, SIZE(dof%h, 1))
        CALL POPREAL8ARRAY(bc%rain%cumul, SIZE(bc%rain, 1))
        CALL POPREAL8ARRAY(bc%sum_mass_flux, SIZE(bc%sum_mass_flux, 1))
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 1) CALL POPREAL8ARRAY(bathy_cell, SIZE(&
&                                       bathy_cell, 1))
        CALL EULER_TIME_STEP_FIRST_B1_BACK(dof, dof_back, mesh)
      END IF
      CALL POPREAL8ARRAY(bc%sum_mass_flux, SIZE(bc%sum_mass_flux, 1))
      bc_back%sum_mass_flux = 0.0_8
      CALL POPREAL8(dt)
      CALL POPINTEGER4(nt)
      CALL POPREAL8(tc)
      CALL POPREAL8ARRAY(bc%inflow, SIZE(bc%inflow, 1))
      CALL POPREAL8ARRAY(bc%outflow, SIZE(bc%outflow, 1))
      CALL POPREAL8ARRAY(bc%rat%zout, SIZE(bc%rat, 1))
      CALL POPREAL8ARRAY(bc%rain%qin, SIZE(bc%rain, 1))
      CALL SET_BC_BACK(dof, dof_back, mesh)
    END DO
  END SUBROUTINE SUB_RUN_MODEL_BACK

  SUBROUTINE SUB_RUN_MODEL()

  USE M_TAP_VARS ! Added by Perl Script -> Need to be filled !!!

    IMPLICIT NONE
    sub_nt = 0
    DO WHILE (.NOT.end_time_loop .AND. sub_nt .LT. max_nt_for_adjoint)
      CALL SET_BC(dof, mesh) ! Replaced by Perl Script
      CALL ADVANCE_TIME(dof, mesh) ! Replaced by Perl Script
      bc%sum_mass_flux(:) = 0._rp
      SELECT CASE  (temp_scheme) 
      CASE ('euler') 
        SELECT CASE  (spatial_scheme) 
        CASE ('first_b1') 
          CALL EULER_TIME_STEP_FIRST_B1(dof, mesh) ! Replaced by Perl Script
        END SELECT
      END SELECT
      CALL SW_POST_TREATMENT(dof, mesh) ! Replaced by Perl Script
      IF (use_obs .EQ. 1) CALL CALC_INNOVATION(dof, mesh) ! Replaced by Perl Script
      IF (.NOT.use_obs .EQ. 1) CALL UPDATE_COST_FUNCTION(dof, cost)
      sub_nt = sub_nt + 1
    END DO
  END SUBROUTINE SUB_RUN_MODEL

END SUBROUTINE RUN_MODEL_BACK

