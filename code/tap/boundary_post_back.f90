!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (master) -  9 Oct 2020 17:47
!
!  Differentiation of boundary_post in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: *(bc.inflow) *(bc.sum_mass_flux)
!                *bathy_cell mass_flux
!   with respect to varying inputs: *(bc.inflow) *(bc.sum_mass_flux)
!                *bathy_cell mass_flux
!   Plus diff mem management of: bc.inflow:in bc.sum_mass_flux:in
!                bathy_cell:in
SUBROUTINE BOUNDARY_POST_BACK(mass_flux, mass_flux_back, index_ghost, &
& mesh)
  USE M_COMMON ! Replaced by Perl Script
  USE M_MESH ! Replaced by Perl Script
  USE M_MODEL ! Replaced by Perl Script

  USE M_TAP_VARS ! Added by Perl Script -> Need to be filled !!!

  IMPLICIT NONE
  TYPE(MSH), INTENT(IN) :: mesh
  REAL(rp), INTENT(IN) :: mass_flux
  REAL(rp) :: mass_flux_back
  INTEGER(ip), INTENT(IN) :: index_ghost
  INTEGER(ip) :: group
  INTEGER :: branch
  ib = mesh%edge(ie)%lim
  group = mesh%edgeb(ib)%group
  IF (mesh%edgeb(ib)%typlim(1:8) .EQ. 'discharg') THEN
    IF (feedback_inflow .EQ. 1) THEN
      CALL PUSHCONTROL2B(0)
    ELSE
      CALL PUSHCONTROL2B(1)
    END IF
  ELSE
    CALL PUSHCONTROL2B(2)
  END IF
  IF ((((mesh%edgeb(ib)%typlim(1:6) .EQ. 'transm' .OR. mesh%edgeb(ib)%&
&     typlim(1:7) .EQ. 'neumann') .OR. mesh%edgeb(ib)%typlim(1:8) .EQ. &
&     'ratcurve') .OR. mesh%edgeb(ib)%typlim(1:7) .EQ. 'zspresc') .OR. &
&     mesh%edgeb(ib)%typlim(1:6) .EQ. 'hpresc') THEN
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
  IF (mesh%edgeb(ib)%typlim(1:11) .EQ. 'internal_2D') mass_flux_back = &
&     mass_flux_back + mesh%edge(ie)%length*bc_back%sum_mass_flux(group)
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) mass_flux_back = mass_flux_back + mesh%edge(ie)%&
&     length*bc_back%sum_mass_flux(group)
  CALL POPCONTROL2B(branch)
  IF (branch .EQ. 0) THEN
    mass_flux_back = mass_flux_back + coef_feedback*bathy_cell_back(&
&     index_ghost)
    bc_back%inflow(mesh%neb+ib) = bc_back%inflow(mesh%neb+ib) - &
&     coef_feedback*bathy_cell_back(index_ghost)
  ELSE IF (branch .NE. 1) THEN
    GOTO 100
  END IF
  mass_flux_back = mass_flux_back - mesh%edge(ie)%length*bc_back%&
&   sum_mass_flux(group)
 100 CONTINUE
END SUBROUTINE BOUNDARY_POST_BACK

