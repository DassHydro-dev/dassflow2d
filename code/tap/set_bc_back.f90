!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (master) -  9 Oct 2020 17:47
!
!  Differentiation of set_bc in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: *(bc.inflow) *(bc.outflow)
!                *(*(bc.hyd).t) *(*(bc.hyd).q) *(*(bc.rat).h) *(*(bc.rat).q)
!                *(bc.rat).zout *(*(bc.rain).t) *(*(bc.rain).q)
!                *(bc.rain).qin *(bc.sum_mass_flux) *bathy_cell
!                *(dof.h) *(dof.u) *(dof.v)
!   with respect to varying inputs: *(bc.inflow) *(bc.outflow)
!                *(*(bc.hyd).t) *(*(bc.hyd).q) *(*(bc.rat).h) *(*(bc.rat).q)
!                *(bc.rat).zout *(*(bc.rain).t) *(*(bc.rain).q)
!                *(bc.rain).qin *(bc.sum_mass_flux) *bathy_cell
!                *(dof.h) *(dof.u) *(dof.v)
!   Plus diff mem management of: bc.inflow:in bc.outflow:in bc.hyd:in
!                *(bc.hyd).t:in *(bc.hyd).q:in bc.rat:in *(bc.rat).h:in
!                *(bc.rat).q:in bc.rain:in *(bc.rain).t:in *(bc.rain).q:in
!                bc.sum_mass_flux:in bathy_cell:in dof.h:in dof.u:in
!                dof.v:in
SUBROUTINE SET_BC_BACK(dof, dof_back, mesh)
  USE M_NUMERIC ! Replaced by Perl Script
  USE M_NUMERIC_BACK
  USE M_MODEL ! Replaced by Perl Script

  USE M_TAP_VARS ! Added by Perl Script -> Need to be filled !!!

  IMPLICIT NONE
  TYPE(MSH), INTENT(IN) :: mesh
  TYPE(UNK), INTENT(IN) :: dof
  TYPE(UNK) :: dof_back
  REAL(rp) :: sum_pow_h, zin, qin, qout
  REAL(rp) :: sum_pow_h_back, zin_back, qin_back, qout_back
  INTEGER(ip) :: num_bc, up_num_bc, down_num_bc, connected_num_bc
  INTRINSIC MAX
  REAL(rp) :: y1
  REAL(rp) :: y1_back
  REAL(rp) :: y2
  REAL(rp) :: y2_back
  REAL(rp) :: max1
  REAL(rp) :: max1_back
  REAL(rp) :: temp_back
  REAL(rp) :: tmp
  REAL(rp) :: tmp_back
  REAL(rp) :: temp_back0
  REAL(rp) :: tmp0
  REAL(rp) :: tmp_back0
  INTEGER :: branch
  CALL PUSHREAL8ARRAY(bc%inflow, SIZE(bc%inflow, 1))
  bc%inflow = zero
  CALL PUSHREAL8ARRAY(bc%outflow, SIZE(bc%outflow, 1))
  bc%outflow = zero
  DO num_bc=1,bc%nb
    IF (bc%typ(num_bc, 1) .EQ. 'discharg1') THEN
      IF (bc%typ(num_bc, 2) .EQ. 'file') THEN
        CALL PUSHREAL8(qin)
        qin = LINEAR_INTERP(bc%hyd(bc%grpf(num_bc))%t, bc%hyd(bc%grpf(&
&         num_bc))%q, tc)
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
!write(*,*) " bc%typ(num_bc,2) == 'file'  must be fill to define qin bc"
      CALL PUSHREAL8(sum_pow_h)
      sum_pow_h = zero
      DO ib=1,mesh%neb
        IF (mesh%edgeb(ib)%typlim .EQ. 'discharg1' .AND. mesh%edgeb(ib)%&
&           group .EQ. num_bc) THEN
          CALL PUSHINTEGER4(ie)
          ie = mesh%edgeb(ib)%ind
          i = mesh%edge(ie)%cell(1)
          IF (dof%h(i) .GT. heps) THEN
            sum_pow_h = sum_pow_h + dof%h(i)**d5p3*mesh%edge(ie)%length
            CALL PUSHCONTROL2B(2)
          ELSE
            CALL PUSHCONTROL2B(1)
          END IF
        ELSE
          CALL PUSHCONTROL2B(0)
        END IF
      END DO
      DO ib=1,mesh%neb
        IF (mesh%edgeb(ib)%typlim .EQ. 'discharg1' .AND. mesh%edgeb(ib)%&
&           group .EQ. num_bc) THEN
          CALL PUSHINTEGER4(ie)
          ie = mesh%edgeb(ib)%ind
          i = mesh%edge(ie)%cell(1)
          IF (dof%h(i) .GT. heps) THEN
            CALL PUSHREAL8(bc%inflow(ib))
            bc%inflow(ib) = -(qin*dof%h(i)**d2p3/sum_pow_h)
            tmp = dof%h(i)*bc%inflow(ib)
            CALL PUSHREAL8(bc%inflow(mesh%neb+ib))
            bc%inflow(mesh%neb+ib) = tmp
            CALL PUSHCONTROL2B(2)
          ELSE
            CALL PUSHCONTROL2B(1)
          END IF
        ELSE
          CALL PUSHCONTROL2B(0)
        END IF
      END DO
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (bc%typ(num_bc, 1) .EQ. 'discharg2') THEN
      IF (bc%typ(num_bc, 2) .EQ. 'file') THEN
        CALL PUSHREAL8(qin)
        qin = LINEAR_INTERP(bc%hyd(bc%grpf(num_bc))%t, bc%hyd(bc%grpf(&
&         num_bc))%q, tc)
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
!write(*,*) " bc%typ(num_bc,2) == 'file'  must be fill to define qin bc"
      CALL PUSHINTEGER4(ie)
      CALL NEWTON_QIN(qin, dof, mesh, zin) ! Replaced by Perl Script
      DO ib=1,mesh%neb
        IF (mesh%edgeb(ib)%typlim .EQ. 'discharg2' .AND. mesh%edgeb(ib)%&
&           group .EQ. num_bc) THEN
          CALL PUSHINTEGER4(ie)
          ie = mesh%edgeb(ib)%ind
          i = mesh%edge(ie)%cell(1)
          j = mesh%edge(ie)%cell(2)
          IF (dof%h(i) .GT. heps) THEN
            IF (0._rp .LT. zin - bathy_cell(j)) THEN
              CALL PUSHREAL8(bc%inflow(ib))
              bc%inflow(ib) = zin - bathy_cell(j)
              CALL PUSHCONTROL2B(2)
            ELSE
              CALL PUSHREAL8(bc%inflow(ib))
              bc%inflow(ib) = 0._rp
              CALL PUSHCONTROL2B(3)
            END IF
          ELSE
            CALL PUSHCONTROL2B(1)
          END IF
        ELSE
          CALL PUSHCONTROL2B(0)
        END IF
      END DO
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (bc%typ(num_bc, 1) .EQ. 'ratcurve') THEN
      IF (nt .EQ. 0) THEN
        CALL PUSHREAL8(qout)
        qout = zero
        DO ib=1,mesh%neb
          IF (mesh%edgeb(ib)%typlim .EQ. 'ratcurve' .AND. mesh%edgeb(ib)&
&             %group .EQ. num_bc) THEN
            CALL PUSHINTEGER4(ie)
            ie = mesh%edgeb(ib)%ind
            i = mesh%edge(ie)%cell(1)
            qout = qout + dof%h(i)*(dof%u(i)*mesh%edge(ie)%normal%x+dof%&
&             v(i)*mesh%edge(ie)%normal%y)*mesh%edge(ie)%length
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
        y1 = LINEAR_INTERP(bc%rat(bc%grpf(num_bc))%q, bc%rat(bc%grpf(&
&         num_bc))%h, qout)
        IF (0._rp .LT. y1) THEN
          CALL PUSHREAL8(bc%rat(bc%grpf(num_bc))%zout)
          bc%rat(bc%grpf(num_bc))%zout = y1
          CALL PUSHCONTROL2B(2)
        ELSE
          CALL PUSHREAL8(bc%rat(bc%grpf(num_bc))%zout)
          bc%rat(bc%grpf(num_bc))%zout = 0._rp
          CALL PUSHCONTROL2B(1)
        END IF
      ELSE
        y2 = LINEAR_INTERP(bc%rat(bc%grpf(num_bc))%q, bc%rat(bc%grpf(&
&         num_bc))%h, bc%sum_mass_flux(num_bc))
        IF (0._rp .LT. y2) THEN
          max1 = y2
          CALL PUSHCONTROL1B(0)
        ELSE
          max1 = 0._rp
          CALL PUSHCONTROL1B(1)
        END IF
        CALL PUSHREAL8(bc%rat(bc%grpf(num_bc))%zout)
        bc%rat(bc%grpf(num_bc))%zout = 0.95_rp*bc%rat(bc%grpf(num_bc))%&
&         zout + 0.05_rp*max1
        CALL PUSHCONTROL2B(0)
      END IF
      CALL PUSHREAL8(sum_pow_h)
      sum_pow_h = zero
      DO ib=1,mesh%neb
        IF (mesh%edgeb(ib)%typlim .EQ. 'ratcurve' .AND. mesh%edgeb(ib)%&
&           group .EQ. num_bc) THEN
          CALL PUSHINTEGER4(ie)
          ie = mesh%edgeb(ib)%ind
          j = mesh%edge(ie)%cell(2)
          IF (0._rp .LT. bc%rat(bc%grpf(num_bc))%zout - bathy_cell(j) + &
&             bc%rat(bc%grpf(num_bc))%z_rat_ref) THEN
            CALL PUSHREAL8(bc%outflow(ib))
            bc%outflow(ib) = bc%rat(bc%grpf(num_bc))%zout - bathy_cell(j&
&             ) + bc%rat(bc%grpf(num_bc))%z_rat_ref
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHREAL8(bc%outflow(ib))
            bc%outflow(ib) = 0._rp
            CALL PUSHCONTROL1B(1)
          END IF
          sum_pow_h = sum_pow_h + bc%outflow(ib)**d5p3*mesh%edge(ie)%&
&           length
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
      END DO
      IF (sum_pow_h .GT. zerom) THEN
        DO ib=1,mesh%neb
          IF (mesh%edgeb(ib)%typlim .EQ. 'ratcurve' .AND. mesh%edgeb(ib)&
&             %group .EQ. num_bc) THEN
            CALL PUSHREAL8(qout)
            qout = LINEAR_INTERP(bc%rat(bc%grpf(num_bc))%h(:), bc%rat(bc&
&             %grpf(num_bc))%q(:), bc%rat(bc%grpf(num_bc))%zout)
            tmp0 = bc%outflow(ib)**d2p3*qout/sum_pow_h
            CALL PUSHREAL8(bc%outflow(mesh%neb+ib))
            bc%outflow(mesh%neb+ib) = tmp0
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
        CALL PUSHCONTROL2B(2)
      ELSE
        CALL PUSHCONTROL2B(1)
      END IF
    ELSE
      CALL PUSHCONTROL2B(0)
    END IF
  END DO
  IF (bc_rain .EQ. 1) THEN
    CALL PUSHINTEGER4(i)
    i = bc%nb_rn + 1
    DO i=bc%nb_rn,1,-1
      tc_back = 0.0_8
      CALL LINEAR_INTERP_BACK0(bc%rain(i)%t, bc_back%rain(i)%t, bc%rain(&
&                        i)%q, bc_back%rain(i)%q, tc, tc_back, bc_back%&
&                        rain(i)%qin)
      bc_back%rain(i)%qin = 0.0_8
    END DO
    CALL POPINTEGER4(i)
  ELSE
    bc_back%rain(1)%qin = 0.0_8
  END IF
  qin_back = 0.0_8
  DO num_bc=bc%nb,1,-1
    CALL POPCONTROL2B(branch)
    IF (branch .NE. 0) THEN
      IF (branch .EQ. 1) THEN
        sum_pow_h_back = 0.0_8
      ELSE
        sum_pow_h_back = 0.0_8
        DO ib=mesh%neb,1,-1
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) THEN
            CALL POPREAL8(bc%outflow(mesh%neb+ib))
            tmp_back0 = bc_back%outflow(mesh%neb+ib)
            bc_back%outflow(mesh%neb+ib) = 0.0_8
            IF (.NOT.(bc%outflow(ib) .LE. 0.0 .AND. (d2p3 .EQ. 0.0 .OR. &
&               d2p3 .NE. INT(d2p3)))) bc_back%outflow(ib) = bc_back%&
&               outflow(ib) + d2p3*bc%outflow(ib)**(d2p3-1)*qout*&
&               tmp_back0/sum_pow_h
            temp_back0 = bc%outflow(ib)**d2p3*tmp_back0/sum_pow_h
            qout_back = temp_back0
            sum_pow_h_back = sum_pow_h_back - qout*temp_back0/sum_pow_h
            CALL POPREAL8(qout)
            CALL LINEAR_INTERP_BACK0(bc%rat(bc%grpf(num_bc))%h(:), &
&                              bc_back%rat(bc%grpf(num_bc))%h(:), bc%rat&
&                              (bc%grpf(num_bc))%q(:), bc_back%rat(bc%&
&                              grpf(num_bc))%q(:), bc%rat(bc%grpf(num_bc&
&                              ))%zout, bc_back%rat(bc%grpf(num_bc))%&
&                              zout, qout_back)
          END IF
        END DO
      END IF
      DO ib=mesh%neb,1,-1
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) THEN
          ie = mesh%edgeb(ib)%ind
          IF (.NOT.(bc%outflow(ib) .LE. 0.0 .AND. (d5p3 .EQ. 0.0 .OR. &
&             d5p3 .NE. INT(d5p3)))) bc_back%outflow(ib) = bc_back%&
&             outflow(ib) + d5p3*bc%outflow(ib)**(d5p3-1)*mesh%edge(ie)%&
&             length*sum_pow_h_back
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            j = mesh%edge(ie)%cell(2)
            CALL POPREAL8(bc%outflow(ib))
            bc_back%rat(bc%grpf(num_bc))%zout = bc_back%rat(bc%grpf(&
&             num_bc))%zout + bc_back%outflow(ib)
            bathy_cell_back(j) = bathy_cell_back(j) - bc_back%outflow(ib&
&             )
            bc_back%outflow(ib) = 0.0_8
          ELSE
            CALL POPREAL8(bc%outflow(ib))
            bc_back%outflow(ib) = 0.0_8
          END IF
          CALL POPINTEGER4(ie)
        END IF
      END DO
      CALL POPREAL8(sum_pow_h)
      CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8(bc%rat(bc%grpf(num_bc))%zout)
        max1_back = 0.05_rp*bc_back%rat(bc%grpf(num_bc))%zout
        bc_back%rat(bc%grpf(num_bc))%zout = 0.95_rp*bc_back%rat(bc%grpf(&
&         num_bc))%zout
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          y2_back = max1_back
        ELSE
          y2_back = 0.0_8
        END IF
        CALL LINEAR_INTERP_BACK0(bc%rat(bc%grpf(num_bc))%q, bc_back%rat(&
&                          bc%grpf(num_bc))%q, bc%rat(bc%grpf(num_bc))%h&
&                          , bc_back%rat(bc%grpf(num_bc))%h, bc%&
&                          sum_mass_flux(num_bc), bc_back%sum_mass_flux(&
&                          num_bc), y2_back)
      ELSE
        IF (branch .EQ. 1) THEN
          CALL POPREAL8(bc%rat(bc%grpf(num_bc))%zout)
          bc_back%rat(bc%grpf(num_bc))%zout = 0.0_8
          y1_back = 0.0_8
        ELSE
          CALL POPREAL8(bc%rat(bc%grpf(num_bc))%zout)
          y1_back = bc_back%rat(bc%grpf(num_bc))%zout
          bc_back%rat(bc%grpf(num_bc))%zout = 0.0_8
        END IF
        qout_back = 0.0_8
        CALL LINEAR_INTERP_BACK0(bc%rat(bc%grpf(num_bc))%q, bc_back%rat(&
&                          bc%grpf(num_bc))%q, bc%rat(bc%grpf(num_bc))%h&
&                          , bc_back%rat(bc%grpf(num_bc))%h, qout, &
&                          qout_back, y1_back)
        DO ib=mesh%neb,1,-1
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) THEN
            ie = mesh%edgeb(ib)%ind
            i = mesh%edge(ie)%cell(1)
            temp_back = mesh%edge(ie)%length*qout_back
            dof_back%h(i) = dof_back%h(i) + (mesh%edge(ie)%normal%x*dof%&
&             u(i)+mesh%edge(ie)%normal%y*dof%v(i))*temp_back
            temp_back0 = dof%h(i)*temp_back
            dof_back%u(i) = dof_back%u(i) + mesh%edge(ie)%normal%x*&
&             temp_back0
            dof_back%v(i) = dof_back%v(i) + mesh%edge(ie)%normal%y*&
&             temp_back0
            CALL POPINTEGER4(ie)
          END IF
        END DO
        CALL POPREAL8(qout)
      END IF
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      zin_back = 0.0_8
      DO 100 ib=mesh%neb,1,-1
        CALL POPCONTROL2B(branch)
        IF (branch .LT. 2) THEN
          IF (branch .EQ. 0) GOTO 100
        ELSE IF (branch .EQ. 2) THEN
          j = mesh%edge(ie)%cell(2)
          CALL POPREAL8(bc%inflow(ib))
          zin_back = zin_back + bc_back%inflow(ib)
          bathy_cell_back(j) = bathy_cell_back(j) - bc_back%inflow(ib)
          bc_back%inflow(ib) = 0.0_8
        ELSE
          CALL POPREAL8(bc%inflow(ib))
          bc_back%inflow(ib) = 0.0_8
        END IF
        CALL POPINTEGER4(ie)
 100  CONTINUE
      CALL POPINTEGER4(ie)
      CALL NEWTON_QIN_BACK(qin, qin_back, dof, dof_back, mesh, zin, &
&                    zin_back)
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8(qin)
        tc_back = 0.0_8
        CALL LINEAR_INTERP_BACK0(bc%hyd(bc%grpf(num_bc))%t, bc_back%hyd(&
&                          bc%grpf(num_bc))%t, bc%hyd(bc%grpf(num_bc))%q&
&                          , bc_back%hyd(bc%grpf(num_bc))%q, tc, tc_back&
&                          , qin_back)
        qin_back = 0.0_8
      END IF
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      sum_pow_h_back = 0.0_8
      DO ib=mesh%neb,1,-1
        CALL POPCONTROL2B(branch)
        IF (branch .NE. 0) THEN
          IF (branch .NE. 1) THEN
            ie = mesh%edgeb(ib)%ind
            i = mesh%edge(ie)%cell(1)
            CALL POPREAL8(bc%inflow(mesh%neb+ib))
            tmp_back = bc_back%inflow(mesh%neb+ib)
            bc_back%inflow(mesh%neb+ib) = 0.0_8
            bc_back%inflow(ib) = bc_back%inflow(ib) + dof%h(i)*tmp_back
            IF (dof%h(i) .LE. 0.0 .AND. (d2p3 .EQ. 0.0 .OR. d2p3 .NE. &
&               INT(d2p3))) THEN
              dof_back%h(i) = dof_back%h(i) + bc%inflow(ib)*tmp_back
            ELSE
              dof_back%h(i) = dof_back%h(i) + bc%inflow(ib)*tmp_back - &
&               d2p3*dof%h(i)**(d2p3-1)*qin*bc_back%inflow(ib)/sum_pow_h
            END IF
            CALL POPREAL8(bc%inflow(ib))
            temp_back = -(dof%h(i)**d2p3*bc_back%inflow(ib)/sum_pow_h)
            bc_back%inflow(ib) = 0.0_8
            qin_back = qin_back + temp_back
            sum_pow_h_back = sum_pow_h_back - qin*temp_back/sum_pow_h
          END IF
          CALL POPINTEGER4(ie)
        END IF
      END DO
      DO ib=mesh%neb,1,-1
        CALL POPCONTROL2B(branch)
        IF (branch .NE. 0) THEN
          IF (branch .NE. 1) THEN
            ie = mesh%edgeb(ib)%ind
            i = mesh%edge(ie)%cell(1)
            IF (.NOT.(dof%h(i) .LE. 0.0 .AND. (d5p3 .EQ. 0.0 .OR. d5p3 &
&               .NE. INT(d5p3)))) dof_back%h(i) = dof_back%h(i) + d5p3*&
&               dof%h(i)**(d5p3-1)*mesh%edge(ie)%length*sum_pow_h_back
          END IF
          CALL POPINTEGER4(ie)
        END IF
      END DO
      CALL POPREAL8(sum_pow_h)
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8(qin)
        tc_back = 0.0_8
        CALL LINEAR_INTERP_BACK0(bc%hyd(bc%grpf(num_bc))%t, bc_back%hyd(&
&                          bc%grpf(num_bc))%t, bc%hyd(bc%grpf(num_bc))%q&
&                          , bc_back%hyd(bc%grpf(num_bc))%q, tc, tc_back&
&                          , qin_back)
        qin_back = 0.0_8
      END IF
    END IF
  END DO
  CALL POPREAL8ARRAY(bc%outflow, SIZE(bc%outflow, 1))
  bc_back%outflow = 0.0_8
  CALL POPREAL8ARRAY(bc%inflow, SIZE(bc%inflow, 1))
  bc_back%inflow = 0.0_8
END SUBROUTINE SET_BC_BACK

