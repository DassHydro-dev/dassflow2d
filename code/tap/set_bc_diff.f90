!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (master) -  9 Oct 2020 17:47
!
!  Differentiation of set_bc in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: *(bc.inflow) *(bc.outflow)
!                *(bc.rat).zout *(bc.rain).qin
!   with respect to varying inputs: *(bc.inflow) *(bc.outflow)
!                *(*(bc.hyd).t) *(*(bc.hyd).q) *(*(bc.rat).h) *(*(bc.rat).q)
!                *(bc.rat).zout *(*(bc.rain).t) *(*(bc.rain).q)
!                *(bc.rain).qin *(bc.sum_mass_flux) *bathy_cell
!                *(dof.h) *(dof.u) *(dof.v)
!   Plus diff mem management of: bc.inflow:in bc.outflow:in bc.hyd:in
!                *(bc.hyd).t:in *(bc.hyd).q:in bc.rat:in *(bc.rat).h:in
!                *(bc.rat).q:in bc.rain:in *(bc.rain).t:in *(bc.rain).q:in
!                bc.sum_mass_flux:in bathy_cell:in dof.h:in dof.u:in
!                dof.v:in
SUBROUTINE SET_BC_DIFF(dof, dof_diff, mesh)
  USE M_NUMERIC ! Replaced by Perl Script
  USE M_NUMERIC_DIFF
  USE M_MODEL ! Replaced by Perl Script

  USE M_TAP_VARS ! Added by Perl Script -> Need to be filled !!!

  IMPLICIT NONE
  TYPE(MSH), INTENT(IN) :: mesh
  TYPE(UNK), INTENT(IN) :: dof
  TYPE(UNK), INTENT(IN) :: dof_diff
  REAL(rp) :: sum_pow_h, zin, qin, qout
  REAL(rp) :: sum_pow_h_diff, zin_diff, qin_diff, qout_diff
  INTEGER(ip) :: num_bc, up_num_bc, down_num_bc, connected_num_bc
  INTRINSIC MAX
  REAL(rp) :: y1
  REAL(rp) :: y1_diff
  REAL(rp) :: y2
  REAL(rp) :: y2_diff
  REAL(rp) :: max1
  REAL(rp) :: max1_diff
  REAL(rp) :: pwr1
  REAL(rp) :: pwr1_diff
  REAL(rp) :: temp
  bc_diff%inflow = 0.0_8
  bc%inflow = zero
  bc_diff%outflow = 0.0_8
  bc%outflow = zero
  qin_diff = 0.0_8
  DO num_bc=1,bc%nb
    IF (bc%typ(num_bc, 1) .EQ. 'discharg1') THEN
      IF (bc%typ(num_bc, 2) .EQ. 'file') THEN
        tc_diff = 0.0_8
        qin_diff = LINEAR_INTERP_DIFF(bc%hyd(bc%grpf(num_bc))%t, bc_diff&
&         %hyd(bc%grpf(num_bc))%t, bc%hyd(bc%grpf(num_bc))%q, bc_diff%&
&         hyd(bc%grpf(num_bc))%q, tc, tc_diff, qin)
      END IF
!write(*,*) " bc%typ(num_bc,2) == 'file'  must be fill to define qin bc"
      sum_pow_h = zero
      sum_pow_h_diff = 0.0_8
      DO ib=1,mesh%neb
        IF (mesh%edgeb(ib)%typlim .EQ. 'discharg1' .AND. mesh%edgeb(ib)%&
&           group .EQ. num_bc) THEN
          ie = mesh%edgeb(ib)%ind
          i = mesh%edge(ie)%cell(1)
          IF (dof%h(i) .GT. heps) THEN
            IF (dof%h(i) .LE. 0.0 .AND. (d5p3 .EQ. 0.0 .OR. d5p3 .NE. &
&               INT(d5p3))) THEN
              pwr1_diff = 0.0_8
            ELSE
              pwr1_diff = d5p3*dof%h(i)**(d5p3-1)*dof_diff%h(i)
            END IF
            pwr1 = dof%h(i)**d5p3
            sum_pow_h_diff = sum_pow_h_diff + mesh%edge(ie)%length*&
&             pwr1_diff
            sum_pow_h = sum_pow_h + pwr1*mesh%edge(ie)%length
          END IF
        END IF
      END DO
      DO ib=1,mesh%neb
        IF (mesh%edgeb(ib)%typlim .EQ. 'discharg1' .AND. mesh%edgeb(ib)%&
&           group .EQ. num_bc) THEN
          ie = mesh%edgeb(ib)%ind
          i = mesh%edge(ie)%cell(1)
          IF (dof%h(i) .GT. heps) THEN
            IF (dof%h(i) .LE. 0.0 .AND. (d2p3 .EQ. 0.0 .OR. d2p3 .NE. &
&               INT(d2p3))) THEN
              pwr1_diff = 0.0_8
            ELSE
              pwr1_diff = d2p3*dof%h(i)**(d2p3-1)*dof_diff%h(i)
            END IF
            pwr1 = dof%h(i)**d2p3
            temp = qin*pwr1/sum_pow_h
            bc_diff%inflow(ib) = -((pwr1*qin_diff+qin*pwr1_diff-temp*&
&             sum_pow_h_diff)/sum_pow_h)
            bc%inflow(ib) = -temp
            bc_diff%inflow(mesh%neb+ib) = bc%inflow(ib)*dof_diff%h(i) + &
&             dof%h(i)*bc_diff%inflow(ib)
            bc%inflow(mesh%neb+ib) = dof%h(i)*bc%inflow(ib)
          END IF
        END IF
      END DO
    END IF
    IF (bc%typ(num_bc, 1) .EQ. 'discharg2') THEN
      IF (bc%typ(num_bc, 2) .EQ. 'file') THEN
        tc_diff = 0.0_8
        qin_diff = LINEAR_INTERP_DIFF(bc%hyd(bc%grpf(num_bc))%t, bc_diff&
&         %hyd(bc%grpf(num_bc))%t, bc%hyd(bc%grpf(num_bc))%q, bc_diff%&
&         hyd(bc%grpf(num_bc))%q, tc, tc_diff, qin)
      END IF
!write(*,*) " bc%typ(num_bc,2) == 'file'  must be fill to define qin bc"
      CALL NEWTON_QIN_DIFF(qin, qin_diff, dof, dof_diff, mesh, zin, &
&                    zin_diff)
      DO ib=1,mesh%neb
        IF (mesh%edgeb(ib)%typlim .EQ. 'discharg2' .AND. mesh%edgeb(ib)%&
&           group .EQ. num_bc) THEN
          ie = mesh%edgeb(ib)%ind
          i = mesh%edge(ie)%cell(1)
          j = mesh%edge(ie)%cell(2)
          IF (dof%h(i) .GT. heps) THEN
            IF (0._rp .LT. zin - bathy_cell(j)) THEN
              bc_diff%inflow(ib) = zin_diff - bathy_cell_diff(j)
              bc%inflow(ib) = zin - bathy_cell(j)
            ELSE
              bc_diff%inflow(ib) = 0.0_8
              bc%inflow(ib) = 0._rp
            END IF
          END IF
        END IF
      END DO
    END IF
    IF (bc%typ(num_bc, 1) .EQ. 'ratcurve') THEN
      IF (nt .EQ. 0) THEN
        qout = zero
        qout_diff = 0.0_8
        DO ib=1,mesh%neb
          IF (mesh%edgeb(ib)%typlim .EQ. 'ratcurve' .AND. mesh%edgeb(ib)&
&             %group .EQ. num_bc) THEN
            ie = mesh%edgeb(ib)%ind
            i = mesh%edge(ie)%cell(1)
            temp = mesh%edge(ie)%normal%x*dof%u(i) + mesh%edge(ie)%&
&             normal%y*dof%v(i)
            qout_diff = qout_diff + mesh%edge(ie)%length*(temp*dof_diff%&
&             h(i)+dof%h(i)*(mesh%edge(ie)%normal%x*dof_diff%u(i)+mesh%&
&             edge(ie)%normal%y*dof_diff%v(i)))
            qout = qout + mesh%edge(ie)%length*(dof%h(i)*temp)
          END IF
        END DO
        y1_diff = LINEAR_INTERP_DIFF(bc%rat(bc%grpf(num_bc))%q, bc_diff%&
&         rat(bc%grpf(num_bc))%q, bc%rat(bc%grpf(num_bc))%h, bc_diff%rat&
&         (bc%grpf(num_bc))%h, qout, qout_diff, y1)
        IF (0._rp .LT. y1) THEN
          bc_diff%rat(bc%grpf(num_bc))%zout = y1_diff
          bc%rat(bc%grpf(num_bc))%zout = y1
        ELSE
          bc_diff%rat(bc%grpf(num_bc))%zout = 0.0_8
          bc%rat(bc%grpf(num_bc))%zout = 0._rp
        END IF
      ELSE
        y2_diff = LINEAR_INTERP_DIFF(bc%rat(bc%grpf(num_bc))%q, bc_diff%&
&         rat(bc%grpf(num_bc))%q, bc%rat(bc%grpf(num_bc))%h, bc_diff%rat&
&         (bc%grpf(num_bc))%h, bc%sum_mass_flux(num_bc), bc_diff%&
&         sum_mass_flux(num_bc), y2)
        IF (0._rp .LT. y2) THEN
          max1_diff = y2_diff
          max1 = y2
        ELSE
          max1 = 0._rp
          max1_diff = 0.0_8
        END IF
        bc_diff%rat(bc%grpf(num_bc))%zout = 0.95_rp*bc_diff%rat(bc%grpf(&
&         num_bc))%zout + 0.05_rp*max1_diff
        bc%rat(bc%grpf(num_bc))%zout = 0.95_rp*bc%rat(bc%grpf(num_bc))%&
&         zout + 0.05_rp*max1
      END IF
      sum_pow_h = zero
      sum_pow_h_diff = 0.0_8
      DO ib=1,mesh%neb
        IF (mesh%edgeb(ib)%typlim .EQ. 'ratcurve' .AND. mesh%edgeb(ib)%&
&           group .EQ. num_bc) THEN
          ie = mesh%edgeb(ib)%ind
          i = mesh%edge(ie)%cell(1)
          j = mesh%edge(ie)%cell(2)
          IF (0._rp .LT. bc%rat(bc%grpf(num_bc))%zout - bathy_cell(j) + &
&             bc%rat(bc%grpf(num_bc))%z_rat_ref) THEN
            bc_diff%outflow(ib) = bc_diff%rat(bc%grpf(num_bc))%zout - &
&             bathy_cell_diff(j)
            bc%outflow(ib) = bc%rat(bc%grpf(num_bc))%zout - bathy_cell(j&
&             ) + bc%rat(bc%grpf(num_bc))%z_rat_ref
          ELSE
            bc_diff%outflow(ib) = 0.0_8
            bc%outflow(ib) = 0._rp
          END IF
          IF (bc%outflow(ib) .LE. 0.0 .AND. (d5p3 .EQ. 0.0 .OR. d5p3 &
&             .NE. INT(d5p3))) THEN
            pwr1_diff = 0.0_8
          ELSE
            pwr1_diff = d5p3*bc%outflow(ib)**(d5p3-1)*bc_diff%outflow(ib&
&             )
          END IF
          pwr1 = bc%outflow(ib)**d5p3
          sum_pow_h_diff = sum_pow_h_diff + mesh%edge(ie)%length*&
&           pwr1_diff
          sum_pow_h = sum_pow_h + pwr1*mesh%edge(ie)%length
        END IF
      END DO
      IF (sum_pow_h .GT. zerom) THEN
        DO ib=1,mesh%neb
          IF (mesh%edgeb(ib)%typlim .EQ. 'ratcurve' .AND. mesh%edgeb(ib)&
&             %group .EQ. num_bc) THEN
            ie = mesh%edgeb(ib)%ind
            i = mesh%edge(ie)%cell(1)
            j = mesh%edge(ie)%cell(2)
            qout_diff = LINEAR_INTERP_DIFF(bc%rat(bc%grpf(num_bc))%h(:)&
&             , bc_diff%rat(bc%grpf(num_bc))%h(:), bc%rat(bc%grpf(num_bc&
&             ))%q(:), bc_diff%rat(bc%grpf(num_bc))%q(:), bc%rat(bc%grpf&
&             (num_bc))%zout, bc_diff%rat(bc%grpf(num_bc))%zout, qout)
            IF (bc%outflow(ib) .LE. 0.0 .AND. (d2p3 .EQ. 0.0 .OR. d2p3 &
&               .NE. INT(d2p3))) THEN
              pwr1_diff = 0.0_8
            ELSE
              pwr1_diff = d2p3*bc%outflow(ib)**(d2p3-1)*bc_diff%outflow(&
&               ib)
            END IF
            pwr1 = bc%outflow(ib)**d2p3
            temp = pwr1*qout/sum_pow_h
            bc_diff%outflow(mesh%neb+ib) = (qout*pwr1_diff+pwr1*&
&             qout_diff-temp*sum_pow_h_diff)/sum_pow_h
            bc%outflow(mesh%neb+ib) = temp
          END IF
        END DO
      END IF
    END IF
  END DO
  IF (bc_rain .EQ. 1) THEN
    DO i=1,bc%nb_rn
      tc_diff = 0.0_8
      bc_diff%rain(i)%qin = LINEAR_INTERP_DIFF(bc%rain(i)%t, bc_diff%&
&       rain(i)%t, bc%rain(i)%q, bc_diff%rain(i)%q, tc, tc_diff, bc%rain&
&       (i)%qin)
    END DO
  ELSE
    bc_diff%rain(1)%qin = 0.0_8
    bc%rain(1)%qin = 0._rp
  END IF
END SUBROUTINE SET_BC_DIFF

