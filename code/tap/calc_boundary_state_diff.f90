!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (master) -  9 Oct 2020 17:47
!
!  Differentiation of calc_boundary_state in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: hr ur vr
!   with respect to varying inputs: *(bc.inflow) *(bc.outflow)
!                *bathy_cell hl ul vl zl zr
!   Plus diff mem management of: bc.inflow:in bc.outflow:in bc.hpresc:in
!                *(bc.hpresc).t:in *(bc.hpresc).h:in bc.zspresc:in
!                *(bc.zspresc).t:in *(bc.zspresc).z:in bathy_cell:in
SUBROUTINE CALC_BOUNDARY_STATE_DIFF(mesh, hl, hl_diff, zl, zl_diff, ul, &
& ul_diff, vl, vl_diff, hr, hr_diff, zr, zr_diff, ur, ur_diff, vr, &
& vr_diff)
! add lilian for linear interp
  USE M_NUMERIC ! Replaced by Perl Script
  USE M_NUMERIC_DIFF
  USE M_MODEL ! Replaced by Perl Script

  USE M_TAP_VARS ! Added by Perl Script -> Need to be filled !!!

  IMPLICIT NONE
  TYPE(MSH), INTENT(IN) :: mesh
  REAL(rp), INTENT(IN) :: hl, ul, vl, zl, zr
  REAL(rp), INTENT(IN) :: hl_diff, ul_diff, vl_diff, zl_diff, zr_diff
  REAL(rp), INTENT(OUT) :: hr, ur, vr
  REAL(rp), INTENT(OUT) :: hr_diff, ur_diff, vr_diff
  INTRINSIC SQRT
  INTRINSIC MAX
  REAL(rp) :: y1
  REAL(rp) :: y1_diff
  REAL(rp) :: result1
  REAL(rp) :: result2
  REAL(rp) :: result2_diff
  REAL(rp) :: result3
  REAL(rp) :: result3_diff
  REAL(rp) :: temp
  ib = mesh%edge(ie)%lim
  SELECT CASE  (mesh%edgeb(ib)%typlim) 
  CASE ('neumann') 
    hr_diff = hl_diff
    hr = hl
    ur_diff = ul_diff
    ur = ul
    vr_diff = vl_diff
    vr = vl
  CASE ('wall') 
    hr_diff = hl_diff + zl_diff - zr_diff
    hr = hl + zl - zr
    ur_diff = -ul_diff
    ur = -ul
    vr_diff = vl_diff
    vr = vl
  CASE ('discharg1') 
    hr_diff = hl_diff
    hr = hl
    ur_diff = bc_diff%inflow(ib)
    ur = bc%inflow(ib)
    vr_diff = vl_diff
    vr = vl
  CASE ('discharg2') 
    hr_diff = bc_diff%inflow(ib)
    hr = bc%inflow(ib)
    result1 = SQRT(g)
    temp = SQRT(hl)
    IF (hl .EQ. 0.0) THEN
      result2_diff = 0.0_8
    ELSE
      result2_diff = hl_diff/(2.0*temp)
    END IF
    result2 = temp
    temp = SQRT(hr)
    IF (hr .EQ. 0.0) THEN
      result3_diff = 0.0_8
    ELSE
      result3_diff = hr_diff/(2.0*temp)
    END IF
    result3 = temp
    ur_diff = ul_diff + two*result1*(result2_diff-result3_diff)
    ur = ul + two*result1*(result2-result3)
    vr_diff = vl_diff
    vr = vl
  CASE ('transm') 
    result1 = SQRT(g*hl)
    IF (ul .GT. result1) THEN
      hr_diff = hl_diff
      hr = hl
      ur_diff = ul_diff
      ur = ul
    ELSE IF (ul .GT. 0._rp .AND. hl .GT. heps) THEN
      hr_diff = hl_diff
      hr = hl
      ur_diff = ul_diff
      ur = ul
    ELSE
      hr_diff = hl_diff
      hr = hl
      ur_diff = -ul_diff
      ur = -ul
    END IF
    vr_diff = vl_diff
    vr = vl
  CASE ('ratcurve') 
    hr_diff = bc_diff%outflow(ib)
    hr = bc%outflow(ib)
    ur_diff = bc_diff%outflow(mesh%neb+ib)
    ur = bc%outflow(mesh%neb+ib)
    vr_diff = vl_diff
    vr = vl
  CASE ('zspresc') 
    result1 = LINEAR_INTERP(bc%zspresc(1)%t, bc%zspresc(1)%z, tc)
    y1_diff = -bathy_cell_diff(mesh%edge(ie)%cell(2))
    y1 = result1 - bathy_cell(mesh%edge(ie)%cell(2))
    IF (0._rp .LT. y1) THEN
      hr_diff = y1_diff
      hr = y1
    ELSE
      hr = 0._rp
      hr_diff = 0.0_8
    END IF
    result1 = SQRT(g)
    temp = SQRT(hl)
    IF (hl .EQ. 0.0) THEN
      result2_diff = 0.0_8
    ELSE
      result2_diff = hl_diff/(2.0*temp)
    END IF
    result2 = temp
    temp = SQRT(hr)
    IF (hr .EQ. 0.0) THEN
      result3_diff = 0.0_8
    ELSE
      result3_diff = hr_diff/(2.0*temp)
    END IF
    result3 = temp
    ur_diff = ul_diff + two*result1*(result2_diff-result3_diff)
    ur = ul + two*result1*(result2-result3)
    vr_diff = vl_diff
    vr = vl
  CASE ('hpresc') 
    hr = LINEAR_INTERP(bc%hpresc(1)%t, bc%hpresc(1)%h, tc)
    result1 = SQRT(g)
    temp = SQRT(hl)
    IF (hl .EQ. 0.0) THEN
      result2_diff = 0.0_8
    ELSE
      result2_diff = hl_diff/(2.0*temp)
    END IF
    result2 = temp
    result3 = SQRT(hr)
    ur_diff = ul_diff + two*result1*result2_diff
    ur = ul + two*result1*(result2-result3)
    vr_diff = vl_diff
    vr = vl
    hr_diff = 0.0_8
  CASE DEFAULT
    hr_diff = hl_diff + zl_diff - zr_diff
    hr = hl + zl - zr
    ur_diff = -ul_diff
    ur = -ul
    vr_diff = vl_diff
    vr = vl
  END SELECT
END SUBROUTINE CALC_BOUNDARY_STATE_DIFF

