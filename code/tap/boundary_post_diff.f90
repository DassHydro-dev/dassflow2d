!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (master) -  9 Oct 2020 17:47
!
!  Differentiation of boundary_post in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: *(bc.sum_mass_flux) *bathy_cell
!   with respect to varying inputs: *(bc.inflow) *(bc.sum_mass_flux)
!                *bathy_cell mass_flux
!   Plus diff mem management of: bc.inflow:in bc.sum_mass_flux:in
!                bathy_cell:in
SUBROUTINE BOUNDARY_POST_DIFF(mass_flux, mass_flux_diff, index_ghost, &
& mesh)
  USE M_COMMON ! Replaced by Perl Script
  USE M_MESH ! Replaced by Perl Script
  USE M_MODEL ! Replaced by Perl Script

  USE M_TAP_VARS ! Added by Perl Script -> Need to be filled !!!

  IMPLICIT NONE
  TYPE(MSH), INTENT(IN) :: mesh
  REAL(rp), INTENT(IN) :: mass_flux
  REAL(rp), INTENT(IN) :: mass_flux_diff
  INTEGER(ip), INTENT(IN) :: index_ghost
  INTEGER(ip) :: group
  ib = mesh%edge(ie)%lim
  group = mesh%edgeb(ib)%group
  IF (mesh%edgeb(ib)%typlim(1:8) .EQ. 'discharg') THEN
    bc_diff%sum_mass_flux(group) = bc_diff%sum_mass_flux(group) - mesh%&
&     edge(ie)%length*mass_flux_diff
    bc%sum_mass_flux(group) = bc%sum_mass_flux(group) - mass_flux*mesh%&
&     edge(ie)%length
    IF (feedback_inflow .EQ. 1) THEN
      bathy_cell_diff(index_ghost) = bathy_cell_diff(index_ghost) + &
&       coef_feedback*(mass_flux_diff-bc_diff%inflow(mesh%neb+ib))
      bathy_cell(index_ghost) = bathy_cell(index_ghost) + coef_feedback*&
&       (mass_flux-bc%inflow(mesh%neb+ib))
    END IF
  END IF
  IF ((((mesh%edgeb(ib)%typlim(1:6) .EQ. 'transm' .OR. mesh%edgeb(ib)%&
&     typlim(1:7) .EQ. 'neumann') .OR. mesh%edgeb(ib)%typlim(1:8) .EQ. &
&     'ratcurve') .OR. mesh%edgeb(ib)%typlim(1:7) .EQ. 'zspresc') .OR. &
&     mesh%edgeb(ib)%typlim(1:6) .EQ. 'hpresc') THEN
    bc_diff%sum_mass_flux(group) = bc_diff%sum_mass_flux(group) + mesh%&
&     edge(ie)%length*mass_flux_diff
    bc%sum_mass_flux(group) = bc%sum_mass_flux(group) + mass_flux*mesh%&
&     edge(ie)%length
  END IF
  IF (mesh%edgeb(ib)%typlim(1:11) .EQ. 'internal_2D') THEN
    bc_diff%sum_mass_flux(group) = bc_diff%sum_mass_flux(group) + mesh%&
&     edge(ie)%length*mass_flux_diff
    bc%sum_mass_flux(group) = bc%sum_mass_flux(group) + mass_flux*mesh%&
&     edge(ie)%length
  END IF
END SUBROUTINE BOUNDARY_POST_DIFF

