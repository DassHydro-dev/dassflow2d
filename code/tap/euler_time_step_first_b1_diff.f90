!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (master) -  9 Oct 2020 17:47
!
!  Differentiation of euler_time_step_first_b1 in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: *(bc.rain).cumul *(bc.sum_mass_flux)
!                *bathy_cell *(dof.h) *(dof.u) *(dof.v) *(dof.infil)
!   with respect to varying inputs: *(infil.ga).psif *(infil.ga).ks
!                *(infil.ga).deltatheta *(infil.scs).lambda *(infil.scs).cn
!                *manning *(bc.inflow) *(bc.outflow) *(bc.rain).qin
!                *(bc.rain).cumul *(bc.sum_mass_flux) *bathy_cell
!                *manning_beta *(dof.h) *(dof.u) *(dof.v) *(dof.infil)
!   Plus diff mem management of: infil.ga:in infil.scs:in manning:in
!                bc.inflow:in bc.outflow:in bc.hpresc:in *(bc.hpresc).t:in
!                *(bc.hpresc).h:in bc.zspresc:in *(bc.zspresc).t:in
!                *(bc.zspresc).z:in bc.rain:in bc.sum_mass_flux:in
!                bathy_cell:in manning_beta:in dof.h:in dof.u:in
!                dof.v:in dof.infil:in
SUBROUTINE EULER_TIME_STEP_FIRST_B1_DIFF(dof, dof_diff, mesh)
  USE M_COMMON ! Replaced by Perl Script
  USE M_MESH ! Replaced by Perl Script
  USE M_MODEL ! Replaced by Perl Script

  USE M_TAP_VARS ! Added by Perl Script -> Need to be filled !!!

  IMPLICIT NONE
  TYPE(MSH), INTENT(INOUT) :: mesh
  TYPE(UNK), INTENT(INOUT) :: dof
  TYPE(UNK), INTENT(INOUT) :: dof_diff
! Left and Right cells indexes to edge
  INTEGER(ip) :: il, ir
! Left State in edge cell normal coordinates
  REAL(rp) :: hl(2), ul(2), vl(2), zl
  REAL(rp) :: hl_diff(2), ul_diff(2), vl_diff(2), zl_diff
! Right State in edge cell normal coordinates
  REAL(rp) :: hr(2), ur(2), vr(2), zr
  REAL(rp) :: hr_diff(2), ur_diff(2), vr_diff(2), zr_diff
! Finite Volume normal edge flux
  REAL(rp), DIMENSION(sw_nb) :: nflux
  REAL(rp), DIMENSION(sw_nb) :: nflux_diff
! Finite Volume edge flux in (x,y) coordinates
  REAL(rp), DIMENSION(sw_nb) :: lflux
  REAL(rp), DIMENSION(sw_nb) :: lflux_diff
! Finite Volume total flux for each cell
  REAL(rp), DIMENSION(sw_nb, mesh%nc) :: tflux
  REAL(rp), DIMENSION(sw_nb, mesh%nc) :: tflux_diff
! Temporal primitive variables
  REAL(rp) :: h, u, v
  REAL(rp) :: h_diff, u_diff, v_diff
! potential maximal retention
  REAL(rp) :: s
  REAL(rp) :: s_diff
! Temporal Fn+1
  REAL(rp) :: fn1
  REAL(rp) :: fn1_diff
  REAL(rp) :: afn1, bfn1
  REAL(rp) :: afn1_diff, bfn1_diff
! local variable of infil calculated depth 
  REAL(rp) :: h_infil
  REAL(rp) :: h_infil_diff
! Velocity norm
  REAL(rp) :: vel
  REAL(rp) :: vel_diff
! Manning
  REAL(rp) :: sfl
  REAL(rp) :: sfl_diff
! mass rain >TGADJ
  REAL(rp) :: madd
  INTRINSIC MAX
  INTRINSIC ABS
  INTRINSIC SQRT
  REAL(rp) :: y1
  REAL(rp) :: y1_diff
  REAL(rp) :: y2
  REAL(rp) :: y2_diff
  REAL(rp) :: abs0
  REAL(rp) :: abs0_diff
  REAL(rp) :: abs1
  REAL(rp) :: abs2
  REAL(rp) :: abs2_diff
  REAL(rp) :: max1
  REAL(rp) :: max1_diff
  REAL(rp) :: max2
  REAL(rp) :: max2_diff
  REAL(rp) :: abs3
  REAL(rp) :: abs3_diff
  REAL(rp) :: abs4
  REAL(rp) :: abs4_diff
  REAL(rp) :: arg1
  REAL(rp) :: arg1_diff
  REAL(rp) :: result1
  REAL(rp) :: result1_diff
  REAL(rp) :: pwr1
  REAL(rp) :: pwr1_diff
  REAL(rp) :: pwr2
  REAL(rp) :: pwr2_diff
  REAL(rp) :: pwr3
  REAL(rp) :: pwr3_diff
  REAL(rp) :: temp
  REAL(rp) :: temp0
  REAL(rp) :: temp1
  tflux(:, :) = 0._rp
  nflux_diff = 0.0_8
  hl_diff = 0.0_8
  ul_diff = 0.0_8
  hr_diff = 0.0_8
  ur_diff = 0.0_8
  tflux_diff = 0.0_8
  vl_diff = 0.0_8
  vr_diff = 0.0_8
  lflux_diff = 0.0_8
  DO 100 ie=1,mesh%ne
    il = mesh%edge(ie)%cell(1)
!Left cell id for a normal cell
    ir = mesh%edge(ie)%cell(2)
    IF (mesh%edge(ie)%boundary) THEN
!Check if bounfary first so typlim exists
      IF (mesh%edgeb(mesh%edge(ie)%lim)%typlim .EQ. 'internal_1D') THEN
        GOTO 100
      ELSE IF (mesh%edgeb(mesh%edge(ie)%lim)%typlim .EQ. 'internal_2D') &
&     THEN
!then change connectivity to connected 1D-like cell
!Get id of the single 1D-like cell with interface in the connected bc number => this should be done once!
        ir = mesh%edge(ie)%cell1d2d
      END IF
    END IF
    hl_diff(1) = dof_diff%h(il)
    hl(1) = dof%h(il)
    hr_diff(1) = dof_diff%h(ir)
    hr(1) = dof%h(ir)
    IF (hl(1) .GT. heps .OR. hr(1) .GT. heps) THEN
! + global_bathy_shift(1)
      zl_diff = bathy_cell_diff(il)
      zl = bathy_cell(il)
! + global_bathy_shift(1)
      zr_diff = bathy_cell_diff(ir)
      zr = bathy_cell(ir)
      ul_diff(1) = dof_diff%u(il)
      ul(1) = dof%u(il)
      vl_diff(1) = dof_diff%v(il)
      vl(1) = dof%v(il)
      ul_diff(2) = mesh%edge(ie)%normal%x*ul_diff(1) + mesh%edge(ie)%&
&       normal%y*vl_diff(1)
      ul(2) = mesh%edge(ie)%normal%x*ul(1) + mesh%edge(ie)%normal%y*vl(1&
&       )
      vl_diff(2) = mesh%edge(ie)%normal%x*vl_diff(1) - mesh%edge(ie)%&
&       normal%y*ul_diff(1)
      vl(2) = mesh%edge(ie)%normal%x*vl(1) - mesh%edge(ie)%normal%y*ul(1&
&       )
      IF (mesh%edge(ie)%boundary) THEN
        IF (.NOT.mesh%edgeb(mesh%edge(ie)%lim)%typlim .EQ. 'internal_2D'&
&       ) THEN
!do not call boundary calculations for internal BCs
          CALL CALC_BOUNDARY_STATE_DIFF(mesh, hl(1), hl_diff(1), zl, &
&                                 zl_diff, ul(2), ul_diff(2), vl(2), &
&                                 vl_diff(2), hr(1), hr_diff(1), zr, &
&                                 zr_diff, ur(2), ur_diff(2), vr(2), &
&                                 vr_diff(2))
        ELSE
          ur_diff(1) = dof_diff%u(ir)
          ur(1) = dof%u(ir)
          vr_diff(1) = dof_diff%v(ir)
          vr(1) = dof%v(ir)
          ur_diff(2) = mesh%edge(ie)%normal%x*ur_diff(1) + mesh%edge(ie)&
&           %normal%y*vr_diff(1)
          ur(2) = mesh%edge(ie)%normal%x*ur(1) + mesh%edge(ie)%normal%y*&
&           vr(1)
          vr_diff(2) = mesh%edge(ie)%normal%x*vr_diff(1) - mesh%edge(ie)&
&           %normal%y*ur_diff(1)
          vr(2) = mesh%edge(ie)%normal%x*vr(1) - mesh%edge(ie)%normal%y*&
&           ur(1)
        END IF
      ELSE
        ur_diff(1) = dof_diff%u(ir)
        ur(1) = dof%u(ir)
        vr_diff(1) = dof_diff%v(ir)
        vr(1) = dof%v(ir)
        ur_diff(2) = mesh%edge(ie)%normal%x*ur_diff(1) + mesh%edge(ie)%&
&         normal%y*vr_diff(1)
        ur(2) = mesh%edge(ie)%normal%x*ur(1) + mesh%edge(ie)%normal%y*vr&
&         (1)
        vr_diff(2) = mesh%edge(ie)%normal%x*vr_diff(1) - mesh%edge(ie)%&
&         normal%y*ur_diff(1)
        vr(2) = mesh%edge(ie)%normal%x*vr(1) - mesh%edge(ie)%normal%y*ur&
&         (1)
      END IF
      IF (zl .LT. zr) THEN
        max1_diff = zr_diff
        max1 = zr
      ELSE
        max1_diff = zl_diff
        max1 = zl
      END IF
      y1_diff = hl_diff(1) + zl_diff - max1_diff
      y1 = hl(1) + zl - max1
      IF (0._rp .LT. y1) THEN
        hl_diff(2) = y1_diff
        hl(2) = y1
      ELSE
        hl_diff(2) = 0.0_8
        hl(2) = 0._rp
      END IF
      IF (zl .LT. zr) THEN
        max2_diff = zr_diff
        max2 = zr
      ELSE
        max2_diff = zl_diff
        max2 = zl
      END IF
      y2_diff = hr_diff(1) + zr_diff - max2_diff
      y2 = hr(1) + zr - max2
      IF (0._rp .LT. y2) THEN
        hr_diff(2) = y2_diff
        hr(2) = y2
      ELSE
        hr_diff(2) = 0.0_8
        hr(2) = 0._rp
      END IF
      CALL SW_HLLC_DIFF(hl(2), hl_diff(2), ul(2), ul_diff(2), vl(2), &
&                 vl_diff(2), hr(2), hr_diff(2), ur(2), ur_diff(2), vr(2&
&                 ), vr_diff(2), nflux, nflux_diff)
      IF (mesh%edge(ie)%boundary) CALL BOUNDARY_POST_DIFF(nflux(1), &
&                                                   nflux_diff(1), ir, &
&                                                   mesh)
      lflux_diff(1) = nflux_diff(1)
      lflux(1) = nflux(1)
      lflux_diff(2) = mesh%edge(ie)%normal%x*nflux_diff(2) - mesh%edge(&
&       ie)%normal%y*nflux_diff(3)
      lflux(2) = mesh%edge(ie)%normal%x*nflux(2) - mesh%edge(ie)%normal%&
&       y*nflux(3)
      lflux_diff(3) = mesh%edge(ie)%normal%y*nflux_diff(2) + mesh%edge(&
&       ie)%normal%x*nflux_diff(3)
      lflux(3) = mesh%edge(ie)%normal%y*nflux(2) + mesh%edge(ie)%normal%&
&       x*nflux(3)
      lflux_diff(1:3) = mesh%edge(ie)%length*lflux_diff(1:3)
      lflux(1:3) = lflux(1:3)*mesh%edge(ie)%length
      tflux_diff(1, il) = tflux_diff(1, il) + lflux_diff(1)
      tflux(1, il) = tflux(1, il) + lflux(1)
      tflux_diff(2, il) = tflux_diff(2, il) + lflux_diff(2)
      tflux(2, il) = tflux(2, il) + lflux(2)
      tflux_diff(3, il) = tflux_diff(3, il) + lflux_diff(3)
      tflux(3, il) = tflux(3, il) + lflux(3)
      temp = 0.5_rp*mesh%edge(ie)%normal%x*mesh%edge(ie)%length*g
      tflux_diff(2, il) = tflux_diff(2, il) + temp*(2*hl(1)*hl_diff(1)-2&
&       *hl(2)*hl_diff(2))
      tflux(2, il) = tflux(2, il) + temp*(hl(1)*hl(1)-hl(2)*hl(2))
      temp = 0.5_rp*mesh%edge(ie)%normal%y*mesh%edge(ie)%length*g
      tflux_diff(3, il) = tflux_diff(3, il) + temp*(2*hl(1)*hl_diff(1)-2&
&       *hl(2)*hl_diff(2))
      tflux(3, il) = tflux(3, il) + temp*(hl(1)*hl(1)-hl(2)*hl(2))
      IF (.NOT.mesh%edge(ie)%boundary .AND. (.NOT.mesh%edge(ie)%&
&         subdomain)) THEN
        tflux_diff(1, ir) = tflux_diff(1, ir) - lflux_diff(1)
        tflux(1, ir) = tflux(1, ir) - lflux(1)
        tflux_diff(2, ir) = tflux_diff(2, ir) - lflux_diff(2)
        tflux(2, ir) = tflux(2, ir) - lflux(2)
        tflux_diff(3, ir) = tflux_diff(3, ir) - lflux_diff(3)
        tflux(3, ir) = tflux(3, ir) - lflux(3)
        temp = 0.5_rp*mesh%edge(ie)%normal%x*mesh%edge(ie)%length*g
        tflux_diff(2, ir) = tflux_diff(2, ir) - temp*(2*hr(1)*hr_diff(1)&
&         -2*hr(2)*hr_diff(2))
        tflux(2, ir) = tflux(2, ir) - temp*(hr(1)*hr(1)-hr(2)*hr(2))
        temp = 0.5_rp*mesh%edge(ie)%normal%y*mesh%edge(ie)%length*g
        tflux_diff(3, ir) = tflux_diff(3, ir) - temp*(2*hr(1)*hr_diff(1)&
&         -2*hr(2)*hr_diff(2))
        tflux(3, ir) = tflux(3, ir) - temp*(hr(1)*hr(1)-hr(2)*hr(2))
      END IF
      IF (mesh%edge(ie)%boundary) THEN
        IF (mesh%edgeb(mesh%edge(ie)%lim)%typlim .EQ. 'internal_2D') &
&       THEN
          tflux_diff(1, ir) = tflux_diff(1, ir) - lflux_diff(1)
          tflux(1, ir) = tflux(1, ir) - lflux(1)
          tflux_diff(2, ir) = tflux_diff(2, ir) - lflux_diff(2)
          tflux(2, ir) = tflux(2, ir) - lflux(2)
          tflux_diff(3, ir) = tflux_diff(3, ir) - lflux_diff(3)
          tflux(3, ir) = tflux(3, ir) - lflux(3)
          temp = 0.5_rp*mesh%edge(ie)%normal%x*mesh%edge(ie)%length*g
          tflux_diff(2, ir) = tflux_diff(2, ir) - temp*(2*hr(1)*hr_diff(&
&           1)-2*hr(2)*hr_diff(2))
          tflux(2, ir) = tflux(2, ir) - temp*(hr(1)*hr(1)-hr(2)*hr(2))
          temp = 0.5_rp*mesh%edge(ie)%normal%y*mesh%edge(ie)%length*g
          tflux_diff(3, ir) = tflux_diff(3, ir) - temp*(2*hr(1)*hr_diff(&
&           1)-2*hr(2)*hr_diff(2))
          tflux(3, ir) = tflux(3, ir) - temp*(hr(1)*hr(1)-hr(2)*hr(2))
        END IF
      END IF
    END IF
 100 CONTINUE
  DO k=1,bc%nb_rn
    bc_diff%rain(k)%cumul = bc_diff%rain(k)%cumul + dt*bc_diff%rain(k)%&
&     qin
    bc%rain(k)%cumul = bc%rain(k)%cumul + dt*bc%rain(k)%qin
  END DO
  DO i=1,mesh%nc
    h_diff = dof_diff%h(i)
    h = dof%h(i)
    u_diff = dof_diff%u(i)
    u = dof%u(i)
    v_diff = dof_diff%v(i)
    v = dof%v(i)
    IF (0._rp .LT. h - dt*tflux(1, i)*mesh%cell(i)%invsurf) THEN
      temp = dt*mesh%cell(i)%invsurf
      dof_diff%h(i) = h_diff - temp*tflux_diff(1, i)
      dof%h(i) = h - temp*tflux(1, i)
    ELSE
      dof_diff%h(i) = 0.0_8
      dof%h(i) = 0._rp
    END IF
    IF (bc_rain .EQ. 1) THEN
!Get rain group for current cell
      k = mesh%cell(i)%rain
      IF (k .GT. 0) THEN
        IF (bc_infil .EQ. 2 .AND. infil%land(i) .NE. 0) THEN
          IF (infil%scs(infil%land(i))%cn .GE. 0.) THEN
            abs0_diff = infil_diff%scs(infil%land(i))%cn
            abs0 = infil%scs(infil%land(i))%cn
          ELSE
            abs0_diff = -infil_diff%scs(infil%land(i))%cn
            abs0 = -infil%scs(infil%land(i))%cn
          END IF
! infil%land(i) is infiltration group for current cell
          s_diff = -(25.4_rp*abs0_diff/abs0**2)
          s = 25.4_rp*(1000._rp/abs0-10._rp)/1000._rp
          IF (infil%scs(infil%land(i))%lambda .GE. 0.) THEN
            abs1 = infil%scs(infil%land(i))%lambda
          ELSE
            abs1 = -infil%scs(infil%land(i))%lambda
          END IF
          IF (bc%rain(k)%cumul .GT. abs1*s) THEN
            IF (infil%scs(infil%land(i))%lambda .GE. 0.) THEN
              abs2_diff = infil_diff%scs(infil%land(i))%lambda
              abs2 = infil%scs(infil%land(i))%lambda
            ELSE
              abs2_diff = -infil_diff%scs(infil%land(i))%lambda
              abs2 = -infil%scs(infil%land(i))%lambda
            END IF
            IF (infil%scs(infil%land(i))%lambda .GE. 0.) THEN
              abs3_diff = infil_diff%scs(infil%land(i))%lambda
              abs3 = infil%scs(infil%land(i))%lambda
            ELSE
              abs3_diff = -infil_diff%scs(infil%land(i))%lambda
              abs3 = -infil%scs(infil%land(i))%lambda
            END IF
            IF (infil%scs(infil%land(i))%lambda .GE. 0.) THEN
              abs4_diff = infil_diff%scs(infil%land(i))%lambda
              abs4 = infil%scs(infil%land(i))%lambda
            ELSE
              abs4_diff = -infil_diff%scs(infil%land(i))%lambda
              abs4 = -infil%scs(infil%land(i))%lambda
            END IF
            temp = bc%rain(k)%cumul + (-abs4+1)*s
            temp0 = bc%rain(k)%cumul - abs3*s
            temp1 = s*temp0/temp
            fn1_diff = s*abs2_diff + abs2*s_diff + (temp0*s_diff+s*(&
&             bc_diff%rain(k)%cumul-s*abs3_diff-abs3*s_diff)-temp1*(&
&             bc_diff%rain(k)%cumul-s*abs4_diff+(1-abs4)*s_diff))/temp
            fn1 = abs2*s + temp1
          ELSE
            fn1_diff = dof_diff%infil(i) + dt*bc_diff%rain(k)%qin
            fn1 = dof%infil(i) + dt*bc%rain(k)%qin
          END IF
!SCS-modified rain
          dof_diff%h(i) = dof_diff%h(i) + dt*bc_diff%rain(k)%qin + &
&           dof_diff%infil(i) - fn1_diff
          dof%h(i) = dof%h(i) + dt*bc%rain(k)%qin - fn1 + dof%infil(i)
          dof_diff%infil(i) = fn1_diff
          dof%infil(i) = fn1
        ELSE
!Unmodified rain
          dof_diff%h(i) = dof_diff%h(i) + dt*bc_diff%rain(k)%qin
          dof%h(i) = dof%h(i) + dt*bc%rain(k)%qin
        END IF
      END IF
    END IF
    IF (bc_infil .EQ. 1) THEN
      IF (infil%land(i) .NE. 0) THEN
!CHECK FORMULATION !CHECK FORMULATION
        afn1_diff = dof_diff%infil(i) + dt*((1._rp-infil%ga(infil%land(i&
&         ))%deltatheta)*infil_diff%ga(infil%land(i))%ks-infil%ga(infil%&
&         land(i))%ks*infil_diff%ga(infil%land(i))%deltatheta)
        afn1 = dof%infil(i) + dt*infil%ga(infil%land(i))%ks*(1._rp-infil&
&         %ga(infil%land(i))%deltatheta)
! infil%land(i) is infiltration group for current cell
        temp1 = dof%infil(i) + dof%h(i) + infil%ga(infil%land(i))%psif
        temp0 = infil%ga(infil%land(i))%ks*infil%ga(infil%land(i))%&
&         deltatheta
        bfn1_diff = dt*(temp1*(infil%ga(infil%land(i))%deltatheta*&
&         infil_diff%ga(infil%land(i))%ks+infil%ga(infil%land(i))%ks*&
&         infil_diff%ga(infil%land(i))%deltatheta)+temp0*(dof_diff%infil&
&         (i)+dof_diff%h(i)+infil_diff%ga(infil%land(i))%psif))
        bfn1 = dt*(temp0*temp1)
!CHECK FORMULATION
        arg1_diff = 2._rp*afn1*afn1_diff + 4._rp*bfn1_diff
        arg1 = afn1**2._rp + 4._rp*bfn1
        temp1 = SQRT(arg1)
        IF (arg1 .EQ. 0.0) THEN
          result1_diff = 0.0_8
        ELSE
          result1_diff = arg1_diff/(2.0*temp1)
        END IF
        result1 = temp1
        fn1_diff = (afn1_diff+result1_diff)/2._rp
        fn1 = (afn1+result1)/2._rp
        h_infil_diff = dof_diff%h(i) + dof_diff%infil(i) - fn1_diff
        h_infil = dof%h(i) + dof%infil(i) - fn1
!-------original code-------
! dof%h(i) = 0._rp
        IF (h_infil .LT. 0._rp) THEN
          fn1_diff = dof_diff%h(i) + dof_diff%infil(i)
          fn1 = dof%h(i) + dof%infil(i)
          h_infil = 0.000001_rp
          h_infil_diff = 0.0_8
        END IF
!replace the local variable h_infil
        dof_diff%h(i) = h_infil_diff
        dof%h(i) = h_infil
        dof_diff%infil(i) = fn1_diff
        dof%infil(i) = fn1
      END IF
    END IF
    IF (dof%h(i) .LE. heps) THEN
      dof_diff%u(i) = 0.0_8
      dof%u(i) = 0._rp
      dof_diff%v(i) = 0.0_8
      dof%v(i) = 0._rp
    ELSE
      temp1 = dt*mesh%cell(i)%invsurf
      temp0 = (h*u-temp1*tflux(2, i))/dof%h(i)
      dof_diff%u(i) = (u*h_diff+h*u_diff-temp1*tflux_diff(2, i)-temp0*&
&       dof_diff%h(i))/dof%h(i)
      dof%u(i) = temp0
      temp1 = dt*mesh%cell(i)%invsurf
      temp0 = (h*v-temp1*tflux(3, i))/dof%h(i)
      dof_diff%v(i) = (v*h_diff+h*v_diff-temp1*tflux_diff(3, i)-temp0*&
&       dof_diff%h(i))/dof%h(i)
      dof%v(i) = temp0
      IF (friction .EQ. 1) THEN
        arg1_diff = 2*dof%u(i)*dof_diff%u(i) + 2*dof%v(i)*dof_diff%v(i)
        arg1 = dof%u(i)**2 + dof%v(i)**2
        temp1 = SQRT(arg1)
        IF (arg1 .EQ. 0.0) THEN
          vel_diff = 0.0_8
        ELSE
          vel_diff = arg1_diff/(2.0*temp1)
        END IF
        vel = temp1
        IF (dof%h(i) .LE. 0.0 .AND. (d2p3 .EQ. 0.0 .OR. d2p3 .NE. INT(&
&           d2p3))) THEN
          pwr1_diff = 0.0_8
        ELSE
          pwr1_diff = d2p3*dof%h(i)**(d2p3-1)*dof_diff%h(i)
        END IF
        pwr1 = dof%h(i)**d2p3
        IF (dof%h(i) .LE. 0.0 .AND. (d4p3 .EQ. 0.0 .OR. d4p3 .NE. INT(&
&           d4p3))) THEN
          pwr2_diff = 0.0_8
        ELSE
          pwr2_diff = d4p3*dof%h(i)**(d4p3-1)*dof_diff%h(i)
        END IF
        pwr2 = dof%h(i)**d4p3
        temp1 = dof%h(i)**manning_beta(land(i))
        IF (dof%h(i) .LE. 0.0 .AND. (manning_beta(land(i)) .EQ. 0.0 .OR.&
&           manning_beta(land(i)) .NE. INT(manning_beta(land(i))))) THEN
          pwr3_diff = 0.0_8
        ELSE IF (dof%h(i) .LE. 0.0) THEN
          pwr3_diff = manning_beta(land(i))*dof%h(i)**(manning_beta(land&
&           (i))-1)*dof_diff%h(i)
        ELSE
          pwr3_diff = manning_beta(land(i))*dof%h(i)**(manning_beta(land&
&           (i))-1)*dof_diff%h(i) + temp1*LOG(dof%h(i))*&
&           manning_beta_diff(land(i))
        END IF
        pwr3 = temp1
        temp1 = 4._rp*dt*g
        temp0 = pwr3*pwr3*vel
        temp = manning(land(i))*manning(land(i))
        arg1_diff = pwr2_diff + temp1*(temp0*2*manning(land(i))*&
&         manning_diff(land(i))+temp*(vel*2*pwr3*pwr3_diff+pwr3**2*&
&         vel_diff))
        arg1 = pwr2 + temp1*(temp*temp0)
        temp1 = SQRT(arg1)
        IF (arg1 .EQ. 0.0) THEN
          result1_diff = 0.0_8
        ELSE
          result1_diff = arg1_diff/(2.0*temp1)
        END IF
        result1 = temp1
        sfl_diff = pwr1_diff + result1_diff
        sfl = pwr1 + result1
        IF (dof%h(i) .LE. 0.0 .AND. (d2p3 .EQ. 0.0 .OR. d2p3 .NE. INT(&
&           d2p3))) THEN
          pwr1_diff = 0.0_8
        ELSE
          pwr1_diff = d2p3*dof%h(i)**(d2p3-1)*dof_diff%h(i)
        END IF
        pwr1 = dof%h(i)**d2p3
        sfl_diff = 2._rp*(pwr1_diff-pwr1*sfl_diff/sfl)/sfl
        sfl = 2._rp*pwr1/sfl
      ELSE IF (friction .EQ. 2) THEN
        sfl_diff = -(dt*manning_diff(land(i)))
        sfl = one - dt*manning(land(i))
      ELSE
        sfl = 1._rp
        sfl_diff = 0.0_8
      END IF
      dof_diff%u(i) = sfl*dof_diff%u(i) + dof%u(i)*sfl_diff
      dof%u(i) = dof%u(i)*sfl
      dof_diff%v(i) = sfl*dof_diff%v(i) + dof%v(i)*sfl_diff
      dof%v(i) = dof%v(i)*sfl
    END IF
  END DO
END SUBROUTINE EULER_TIME_STEP_FIRST_B1_DIFF

