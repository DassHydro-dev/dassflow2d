!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (master) -  9 Oct 2020 17:47
!
!  Differentiation of run_model in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: *(*innovation.diff) *(dof.h)
!                *(dof.u) *(dof.v) cost
!   with respect to varying inputs: *(infil.ga).psif *(infil.ga).ks
!                *(infil.ga).deltatheta *(infil.scs).lambda *(infil.scs).cn
!                *manning *(*(bc.hyd).t) *(*(bc.hyd).q) *(*(bc.rat).h)
!                *(*(bc.rat).q) *(*(bc.rain).t) *(*(bc.rain).q)
!                *bathy_cell *manning_beta *(dof0.h) *(dof0.u)
!                *(dof0.v)
!   RW status of diff variables: tc:(loc) *(infil.ga).psif:in *(infil.ga).ks:in
!                *(infil.ga).deltatheta:in *(infil.scs).lambda:in
!                *(infil.scs).cn:in *manning:in *(bc.inflow):(loc)
!                *(bc.outflow):(loc) *(*(bc.hyd).t):in *(*(bc.hyd).q):in
!                *(*(bc.rat).h):in *(*(bc.rat).q):in *(bc.rat).zout:(loc)
!                *(*(bc.rain).t):in *(*(bc.rain).q):in *(bc.rain).qin:(loc)
!                *(bc.rain).cumul:(loc) *(bc.sum_mass_flux):(loc)
!                *bathy_cell:in-killed *manning_beta:in *(*innovation.diff):out
!                dof.h:(loc) *(dof.h):out dof.u:(loc) *(dof.u):out
!                dof.v:(loc) *(dof.v):out *(dof.infil):(loc) cost:out
!                dof0.h:(loc) *(dof0.h):in dof0.u:(loc) *(dof0.u):in
!                dof0.v:(loc) *(dof0.v):in
!   Plus diff mem management of: infil.ga:in infil.scs:in manning:in
!                bc.inflow:in bc.outflow:in bc.hyd:in *(bc.hyd).t:in
!                *(bc.hyd).q:in bc.rat:in *(bc.rat).h:in *(bc.rat).q:in
!                bc.hpresc:in *(bc.hpresc).t:in *(bc.hpresc).h:in
!                bc.zspresc:in *(bc.zspresc).t:in *(bc.zspresc).z:in
!                bc.rain:in *(bc.rain).t:in *(bc.rain).q:in bc.sum_mass_flux:in
!                bathy_cell:in manning_beta:in innovation:in *innovation.diff:in
!                dof.h:in dof.u:in dof.v:in dof.infil:in dof0.h:in
!                dof0.u:in dof0.v:in
SUBROUTINE RUN_MODEL_DIFF(mesh, dof0, dof0_diff, dof, dof_diff, cost, &
& cost_diff)
  USE M_COMMON ! Replaced by Perl Script
  USE M_LINEAR_ALGEBRA ! Replaced by Perl Script
  USE M_MESH ! Replaced by Perl Script
  USE M_NUMERIC ! Replaced by Perl Script
  USE M_NUMERIC_DIFF
  USE M_MODEL ! Replaced by Perl Script
  USE M_OBS ! Replaced by Perl Script
  USE M_OBS_DIFF

  USE M_TAP_VARS ! Added by Perl Script -> Need to be filled !!!

  IMPLICIT NONE
  TYPE(MSH), INTENT(INOUT) :: mesh
  TYPE(UNK), INTENT(IN) :: dof0
  TYPE(UNK), INTENT(IN) :: dof0_diff
  TYPE(UNK), INTENT(INOUT) :: dof
  TYPE(UNK), INTENT(INOUT) :: dof_diff
  REAL(rp), INTENT(OUT) :: cost
  REAL(rp), INTENT(OUT) :: cost_diff
  INTEGER(ip) :: sub_nt
  INTEGER :: ii1
  dof_diff%h = 0.0_8
  dof_diff%h = dof0_diff%h
  dof%h = dof0%h
  dof_diff%u = 0.0_8
  dof_diff%u = dof0_diff%u
  dof%u = dof0%u
  dof_diff%v = 0.0_8
  dof_diff%v = dof0_diff%v
  dof%v = dof0%v
  tc = tc0
  nt = nt0
  IF (use_obs .EQ. 1) innovation(:)%ind_t = 1_ip
  cost = 0._rp
  end_time_loop = .false.
  bc_diff%inflow = 0.0_8
  bc_diff%outflow = 0.0_8
  bc_diff%rat%zout = 0.0_8
  bc_diff%rain%qin = 0.0_8
  bc_diff%rain%cumul = 0.0_8
  bc_diff%sum_mass_flux = 0.0_8
  IF (ALLOCATED(innovation_diff)) THEN
    DO ii1=1,SIZE(innovation_diff(ii1)%diff, 1)
      innovation_diff(ii1)%diff = 0.0_8
    END DO
  END IF
  dof_diff%infil = 0.0_8
  cost_diff = 0.0_8
  DO WHILE (.NOT.end_time_loop)
    CALL SUB_RUN_MODEL_DIFF()
  END DO
  CALL CALC_COST_FUNCTION_DIFF(cost, cost_diff, mesh)

CONTAINS
!  Differentiation of sub_run_model in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: *(bc.inflow) *(bc.outflow)
!                *(bc.rat).zout *(bc.rain).qin *(bc.rain).cumul
!                *(bc.sum_mass_flux) *bathy_cell *(*innovation.diff)
!                *(dof.h) *(dof.u) *(dof.v) *(dof.infil) cost
!   with respect to varying inputs: *(infil.ga).psif *(infil.ga).ks
!                *(infil.ga).deltatheta *(infil.scs).lambda *(infil.scs).cn
!                *manning *(bc.inflow) *(bc.outflow) *(*(bc.hyd).t)
!                *(*(bc.hyd).q) *(*(bc.rat).h) *(*(bc.rat).q) *(bc.rat).zout
!                *(*(bc.rain).t) *(*(bc.rain).q) *(bc.rain).qin
!                *(bc.rain).cumul *(bc.sum_mass_flux) *bathy_cell
!                *manning_beta *(*innovation.diff) *(dof.h) *(dof.u)
!                *(dof.v) *(dof.infil) cost
!   Plus diff mem management of: infil.ga:in infil.scs:in manning:in
!                bc.inflow:in bc.outflow:in bc.hyd:in *(bc.hyd).t:in
!                *(bc.hyd).q:in bc.rat:in *(bc.rat).h:in *(bc.rat).q:in
!                bc.hpresc:in *(bc.hpresc).t:in *(bc.hpresc).h:in
!                bc.zspresc:in *(bc.zspresc).t:in *(bc.zspresc).z:in
!                bc.rain:in *(bc.rain).t:in *(bc.rain).q:in bc.sum_mass_flux:in
!                bathy_cell:in manning_beta:in innovation:in *innovation.diff:in
!                dof.h:in dof.u:in dof.v:in dof.infil:in
  SUBROUTINE SUB_RUN_MODEL_DIFF()

  USE M_TAP_VARS ! Added by Perl Script -> Need to be filled !!!

    IMPLICIT NONE
    sub_nt = 0
    DO WHILE (.NOT.end_time_loop .AND. sub_nt .LT. max_nt_for_adjoint)
      CALL SET_BC_DIFF(dof, dof_diff, mesh)
      CALL ADVANCE_TIME(dof, mesh) ! Replaced by Perl Script
      bc_diff%sum_mass_flux(:) = 0.0_8
      bc%sum_mass_flux(:) = 0._rp
      SELECT CASE  (temp_scheme) 
      CASE ('euler') 
        SELECT CASE  (spatial_scheme) 
        CASE ('first_b1') 
          CALL EULER_TIME_STEP_FIRST_B1_DIFF(dof, dof_diff, mesh)
        END SELECT
      END SELECT
      CALL SW_POST_TREATMENT_DIFF(dof, mesh)
      IF (use_obs .EQ. 1) CALL CALC_INNOVATION_DIFF(dof, dof_diff, mesh)
      IF (.NOT.use_obs .EQ. 1) CALL UPDATE_COST_FUNCTION_DIFF(dof, &
&                                                       dof_diff, cost, &
&                                                       cost_diff)
      sub_nt = sub_nt + 1
    END DO
  END SUBROUTINE SUB_RUN_MODEL_DIFF

  SUBROUTINE SUB_RUN_MODEL()

  USE M_TAP_VARS ! Added by Perl Script -> Need to be filled !!!

    IMPLICIT NONE
    sub_nt = 0
    DO WHILE (.NOT.end_time_loop .AND. sub_nt .LT. max_nt_for_adjoint)
      CALL SET_BC(dof, mesh) ! Replaced by Perl Script
      CALL ADVANCE_TIME(dof, mesh) ! Replaced by Perl Script
      bc%sum_mass_flux(:) = 0._rp
      SELECT CASE  (temp_scheme) 
      CASE ('euler') 
        SELECT CASE  (spatial_scheme) 
        CASE ('first_b1') 
          CALL EULER_TIME_STEP_FIRST_B1(dof, mesh) ! Replaced by Perl Script
        END SELECT
      END SELECT
      CALL SW_POST_TREATMENT(dof, mesh) ! Replaced by Perl Script
      IF (use_obs .EQ. 1) CALL CALC_INNOVATION(dof, mesh) ! Replaced by Perl Script
      IF (.NOT.use_obs .EQ. 1) CALL UPDATE_COST_FUNCTION(dof, cost)
      sub_nt = sub_nt + 1
    END DO
  END SUBROUTINE SUB_RUN_MODEL

END SUBROUTINE RUN_MODEL_DIFF

