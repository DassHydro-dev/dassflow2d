!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (master) -  9 Oct 2020 17:47
!
!  Differentiation of sw_hllc in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: flux hl ul hr ur vl vr
!   with respect to varying inputs: flux hl ul hr ur vl vr
SUBROUTINE SW_HLLC_BACK(hl, hl_back, ul, ul_back, vl, vl_back, hr, &
& hr_back, ur, ur_back, vr, vr_back, flux, flux_back)
  USE M_COMMON ! Replaced by Perl Script
  USE M_MODEL ! Replaced by Perl Script

  USE M_TAP_VARS ! Added by Perl Script -> Need to be filled !!!

  IMPLICIT NONE
  REAL(rp), INTENT(IN) :: hl, ul, vl
  REAL(rp) :: hl_back, ul_back, vl_back
  REAL(rp), INTENT(IN) :: hr, ur, vr
  REAL(rp) :: hr_back, ur_back, vr_back
  REAL(rp), DIMENSION(3) :: flux
  REAL(rp), DIMENSION(3) :: flux_back
  REAL(rp) :: sl, sr, sm, cl, cr
  REAL(rp) :: sl_back, sr_back, cl_back, cr_back
  REAL(rp), DIMENSION(3) :: fl, fr
  REAL(rp), DIMENSION(3) :: fl_back, fr_back
  INTRINSIC SQRT
  INTRINSIC MIN
  INTRINSIC MAX
  REAL(rp) :: temp_back
  REAL(rp) :: temp_back0
  INTEGER :: branch
  cl = SQRT(g*hl)
  cr = SQRT(g*hr)
  IF (0._rp .GT. ul - cl) THEN
    IF (ul - cl .GT. ur - 2._rp*cr + cl) THEN
      sl = ur - 2._rp*cr + cl
      CALL PUSHCONTROL2B(0)
    ELSE
      sl = ul - cl
      CALL PUSHCONTROL2B(1)
    END IF
  ELSE IF (0._rp .GT. ur - 2._rp*cr + cl) THEN
    sl = ur - 2._rp*cr + cl
    CALL PUSHCONTROL2B(2)
  ELSE
    CALL PUSHCONTROL2B(3)
    sl = 0._rp
  END IF
  IF (0._rp .LT. ur + cr) THEN
    IF (ur + cr .LT. ul + 2._rp*cl - cr) THEN
      sr = ul + 2._rp*cl - cr
      CALL PUSHCONTROL2B(0)
    ELSE
      sr = ur + cr
      CALL PUSHCONTROL2B(1)
    END IF
  ELSE IF (0._rp .LT. ul + 2._rp*cl - cr) THEN
    sr = ul + 2._rp*cl - cr
    CALL PUSHCONTROL2B(2)
  ELSE
    sr = 0._rp
    CALL PUSHCONTROL2B(3)
  END IF
  IF ((sl .GT. -zerom .AND. sr .LT. zerom) .OR. (hl .LT. zerom .AND. hr &
&     .LT. zerom)) THEN
    flux_back = 0.0_8
    sl_back = 0.0_8
    sr_back = 0.0_8
  ELSE
    fl(1) = hl*ul
    fl(2) = hl*ul*ul + 0.5_rp*g*hl*hl
    fr(1) = hr*ur
    fr(2) = hr*ur*ur + 0.5_rp*g*hr*hr
    flux(1) = sr*fl(1) - sl*fr(1) + sl*sr*(hr-hl)
    flux(2) = sr*fl(2) - sl*fr(2) + sl*sr*(fr(1)-fl(1))
    CALL PUSHREAL8ARRAY(flux(1:2), 2)
    flux(1:2) = flux(1:2)/(sr-sl)
    sm = (sl*hr*ur-sr*hl*ul-sl*sr*(hr-hl))/(hr*(ur-sr)-hl*(ul-sl))
    IF (sm .LT. 0._rp) THEN
      flux_back(1) = flux_back(1) + vr*flux_back(3)
      vr_back = vr_back + flux(1)*flux_back(3)
      flux_back(3) = 0.0_8
    ELSE IF (sm .GT. 0._rp) THEN
      flux_back(1) = flux_back(1) + vl*flux_back(3)
      vl_back = vl_back + flux(1)*flux_back(3)
      flux_back(3) = 0.0_8
    ELSE
      flux_back(1) = flux_back(1) + (vl+vr)*demi*flux_back(3)
      temp_back0 = flux(1)*demi*flux_back(3)
      flux_back(3) = 0.0_8
      vl_back = vl_back + temp_back0
      vr_back = vr_back + temp_back0
    END IF
    CALL POPREAL8ARRAY(flux(1:2), 2)
    temp_back0 = -(SUM(flux(1:2)*flux_back(1:2))/(sr-sl)**2)
    flux_back(1:2) = flux_back(1:2)/(sr-sl)
    fl_back = 0.0_8
    fr_back = 0.0_8
    fl_back(2) = fl_back(2) + sr*flux_back(2)
    fr_back(2) = fr_back(2) - sl*flux_back(2)
    temp_back = (fr(1)-fl(1))*flux_back(2)
    sr_back = temp_back0 + fl(2)*flux_back(2) + sl*temp_back + (fl(1)+sl&
&     *(hr-hl))*flux_back(1)
    sl_back = sr*temp_back - temp_back0 - fr(2)*flux_back(2) + (sr*(hr-&
&     hl)-fr(1))*flux_back(1)
    temp_back0 = sl*sr*flux_back(2)
    flux_back(2) = 0.0_8
    fr_back(1) = fr_back(1) + temp_back0 - sl*flux_back(1)
    fl_back(1) = fl_back(1) + sr*flux_back(1) - temp_back0
    temp_back = sl*sr*flux_back(1)
    flux_back(1) = 0.0_8
    hr_back = hr_back + temp_back + (ur**2+2*hr*g*0.5_rp)*fr_back(2) + &
&     ur*fr_back(1)
    hl_back = hl_back + (ul**2+2*hl*g*0.5_rp)*fl_back(2) - temp_back + &
&     ul*fl_back(1)
    ur_back = ur_back + 2*ur*hr*fr_back(2) + hr*fr_back(1)
    fr_back(2) = 0.0_8
    ul_back = ul_back + 2*ul*hl*fl_back(2) + hl*fl_back(1)
    fl_back(2) = 0.0_8
  END IF
  CALL POPCONTROL2B(branch)
  IF (branch .LT. 2) THEN
    IF (branch .EQ. 0) THEN
      ul_back = ul_back + sr_back
      cl_back = 2._rp*sr_back
      cr_back = -sr_back
    ELSE
      ur_back = ur_back + sr_back
      cr_back = sr_back
      cl_back = 0.0_8
    END IF
  ELSE IF (branch .EQ. 2) THEN
    ul_back = ul_back + sr_back
    cl_back = 2._rp*sr_back
    cr_back = -sr_back
  ELSE
    cl_back = 0.0_8
    cr_back = 0.0_8
  END IF
  CALL POPCONTROL2B(branch)
  IF (branch .LT. 2) THEN
    IF (branch .EQ. 0) THEN
      ur_back = ur_back + sl_back
      cr_back = cr_back - 2._rp*sl_back
      cl_back = cl_back + sl_back
    ELSE
      ul_back = ul_back + sl_back
      cl_back = cl_back - sl_back
    END IF
  ELSE IF (branch .EQ. 2) THEN
    ur_back = ur_back + sl_back
    cr_back = cr_back - 2._rp*sl_back
    cl_back = cl_back + sl_back
  END IF
  IF (.NOT.g*hr .EQ. 0.0) hr_back = hr_back + g*cr_back/(2.0*SQRT(g*hr))
  IF (.NOT.g*hl .EQ. 0.0) hl_back = hl_back + g*cl_back/(2.0*SQRT(g*hl))
END SUBROUTINE SW_HLLC_BACK

