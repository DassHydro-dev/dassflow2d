!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (master) -  9 Oct 2020 17:47
!
MODULE M_OBS_DIFF

  USE M_TAP_VARS

CONTAINS
!  Differentiation of calc_cost_function in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: cost
!   with respect to varying inputs: *(*(bc.hyd).q) *(*innovation.diff)
!                cost
!   Plus diff mem management of: bc.hyd:in *(bc.hyd).q:in innovation:in
!                *innovation.diff:in
  SUBROUTINE CALC_COST_FUNCTION_DIFF(cost, cost_diff, mesh)
    USE M_NUMERIC_DIFF
    IMPLICIT NONE
    TYPE(MSH), INTENT(IN) :: mesh
    REAL(rp), INTENT(INOUT) :: cost
    REAL(rp), INTENT(INOUT) :: cost_diff
    REAL(rp) :: cost_part(3), filtered(4)
    REAL(rp) :: cost_part_diff(3), filtered_diff(4)
    INTEGER(ip) :: idiff
    TYPE(VEC2D), DIMENSION(mesh%nc+mesh%ncb) :: grad_var
    INTRINSIC SIZE
    INTRINSIC SUM
    INTRINSIC SQRT
    REAL(rp) :: arg1
    REAL(rp) :: arg1_diff
    REAL(rp) :: temp
    IF (use_obs .EQ. 1) THEN
      cost_part(:) = 0._rp
      cost_part_diff = 0.0_8
      DO iobs=1,SIZE(station)
        DO idiff=1,SIZE(innovation(iobs)%diff)
          cost_part_diff(1) = cost_part_diff(1) + station(iobs)%weight*2&
&           *innovation(iobs)%diff(idiff)*innovation_diff(iobs)%diff(&
&           idiff)
          cost_part(1) = cost_part(1) + station(iobs)%weight*innovation(&
&           iobs)%diff(idiff)**2
        END DO
      END DO
      DO i=1,mesh%nc
        cost_part(2) = cost_part(2) + (grad_var(i)%x**2+grad_var(i)%y**2&
&         )
      END DO
      cost_part_diff(2) = regul_bathy*cost_part_diff(2)
      cost_part(2) = cost_part(2)*regul_bathy
      filtered_diff = 0.0_8
      DO k=1,bc%nb_in
        filtered_diff(1) = bc_diff%hyd(k)%q(1)
        filtered(1) = bc%hyd(k)%q(1)
        DO i=2,SIZE(bc%hyd(k)%q(:))-3
          filtered_diff(2) = filtered_diff(1) + 0.2_rp*(bc_diff%hyd(k)%q&
&           (i)-filtered_diff(1))
          filtered(2) = filtered(1) + 0.2_rp*(bc%hyd(k)%q(i)-filtered(1)&
&           )
          filtered_diff(3) = filtered_diff(2) + 0.2_rp*(bc_diff%hyd(k)%q&
&           (i+1)-filtered_diff(2))
          filtered(3) = filtered(2) + 0.2_rp*(bc%hyd(k)%q(i+1)-filtered(&
&           2))
          filtered_diff(4) = filtered_diff(3) + 0.2_rp*(bc_diff%hyd(k)%q&
&           (i+2)-filtered_diff(3))
          filtered(4) = filtered(3) + 0.2_rp*(bc%hyd(k)%q(i+2)-filtered(&
&           3))
          cost_part_diff(3) = cost_part_diff(3) + 2*(bc%hyd(k)%q(i)-&
&           filtered(4))*(bc_diff%hyd(k)%q(i)-filtered_diff(4))
          cost_part(3) = cost_part(3) + (bc%hyd(k)%q(i)-filtered(4))**2
          filtered_diff(1) = filtered_diff(4)
          filtered(1) = filtered(4)
        END DO
      END DO
      cost_part_diff(3) = regul_hydrograph*cost_part_diff(3)
      cost_part(3) = cost_part(3)*regul_hydrograph
      cost_diff = SUM(cost_part_diff)
      cost = SUM(cost_part)
    END IF
    arg1_diff = 2*cost*cost_diff
    arg1 = cost**2
    temp = SQRT(arg1)
    IF (arg1 .EQ. 0.0) THEN
      cost_diff = 0.0_8
    ELSE
      cost_diff = arg1_diff/(2.0*temp)
    END IF
    cost = temp
  END SUBROUTINE CALC_COST_FUNCTION_DIFF


!  Differentiation of update_cost_function in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: cost
!   with respect to varying inputs: *(dof.h) cost
!   Plus diff mem management of: dof.h:in
  SUBROUTINE UPDATE_COST_FUNCTION_DIFF(dof, dof_diff, cost, cost_diff)
    IMPLICIT NONE
    TYPE(UNK), INTENT(IN) :: dof
    TYPE(UNK), INTENT(IN) :: dof_diff
    REAL(rp), INTENT(INOUT) :: cost
    REAL(rp), INTENT(INOUT) :: cost_diff
    INTEGER(ip) :: cell, pt
    REAL(rp) :: h_mean
    REAL(rp) :: h_mean_diff
    INTRINSIC ALLOCATED
    INTRINSIC SIZE
    INTRINSIC REAL
    LOGICAL :: result1
    INTEGER :: arg1
    REAL*8 :: temp
    IF (.NOT.ALLOCATED(station)) THEN
      RETURN
    ELSE
      DO iobs=1,SIZE(station)
        result1 = TEST_DT_JUST_AFTER(station(iobs)%dt)
        IF (result1) THEN
          h_mean = 0._rp
          h_mean_diff = 0.0_8
          DO pt=1,SIZE(station(iobs)%pt)
            cell = station(iobs)%pt(pt)%cell
            IF (cell .GE. 0) THEN
              h_mean_diff = h_mean_diff + dof_diff%h(cell)
              h_mean = h_mean + dof%h(cell)
            END IF
          END DO
          arg1 = SIZE(station(iobs)%pt)
          temp = REAL(arg1, 8)
          h_mean_diff = h_mean_diff/temp
          h_mean = h_mean/temp
          cost_diff = cost_diff + station(iobs)%weight*2*h_mean*&
&           h_mean_diff
          cost = cost + station(iobs)%weight*h_mean**2
        END IF
      END DO
    END IF
  END SUBROUTINE UPDATE_COST_FUNCTION_DIFF


END MODULE M_OBS_DIFF

